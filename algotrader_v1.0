# =====================
# CORE IMPORTS
# =====================
from ib_insync import IB, Stock, util
import pandas as pd
import numpy as np
import mplfinance as mpf
from datetime import datetime, timedelta, time
import asyncio
import nest_asyncio
import logging
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from time import sleep
from matplotlib.colors import ListedColormap, Normalize, LinearSegmentedColormap
from collections.abc import MutableMapping
import pytz
import matplotlib.patheffects as pe
from matplotlib.cm import ScalarMappable
import seaborn as sns
from matplotlib.dates import DateFormatter
from scipy.signal import savgol_filter
import sys
from concurrent.futures import ThreadPoolExecutor
import statsmodels.api as sm
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.model_selection import ParameterGrid
from bayes_opt import BayesianOptimization

param_grid = {
    'bollinger_zscore': [-3.0, -2.5, -2.0],
    'band_width': [0.03, 0.05, 0.07],
    'volume_spike': [1.2, 1.5, 2.0],
    'mean_reversion': [0.3, 0.5, 0.7],
    'stop_loss': [-0.01, -0.02, -0.03],
    'trailing_stop_atr': [0.5, 1.0, 1.5]
}

def optimize_strategy(df, timeframe='5 mins', strategy_id='A'):
    """Optimize any strategy using Bayesian optimization."""
    logger.info(f"Starting Bayesian optimization for Strategy {strategy_id} on {timeframe}")

    # Define strategy-specific parameter bounds
    strategy_bounds = {
        'A': {  # Bollinger Bands MR
            'zscore': (-3.0, -1.5),
            'band_width': (0.03, 0.10),
            'volume_spike': (1.2, 2.5),
            'mean_reversion': (0.3, 1.0),
            'stop_loss': (-0.03, -0.01),
            'trailing_atr': (0.5, 2.0)
        },
        'B': {  # PCA Stat Arb
            'zscore_entry': (-2.5, -1.0),
            'zscore_exit': (-1.0, 0.0),
            'profit_target': (0.2, 1.0),
            'stop_loss': (-3.0, -1.5),
            'volatility_mult': (0.5, 2.0),
            'position_risk': (0.01, 0.05)
        }
    }

    if strategy_id not in strategy_bounds:
        logger.error(f"Strategy {strategy_id} not supported for optimization")
        return None

    pbounds = strategy_bounds[strategy_id]
    mode = GlobalConfig.STRATEGIES[strategy_id]

    def evaluate_strategy(**params):
        # Initialize backtest engine with the given strategy
        engine = BacktestEngine(strategy_id, mode, timeframe)
        
        # Update engine configuration with optimization parameters
        if strategy_id == 'A':
            engine.mode_config['bollinger_reversion']['entry_conditions']['bollinger_zscore']['threshold'] = params['zscore']
            engine.mode_config['bollinger_reversion']['entry_conditions']['band_width']['threshold'] = params['band_width']
            engine.mode_config['bollinger_reversion']['entry_conditions']['volume_spike']['threshold'] = params['volume_spike']
            engine.mode_config['bollinger_reversion']['exit_conditions']['mean_reversion']['threshold'] = lambda row: params['mean_reversion']
            engine.mode_config['bollinger_reversion']['exit_conditions']['stop_loss']['threshold'] = params['stop_loss']
            engine.mode_config['bollinger_reversion']['exit_conditions']['trailing_stop']['atr_multiplier'] = params['trailing_atr']
        elif strategy_id == 'B':
            engine.mode_config['pca_stat_arb']['entry_conditions']['zscore']['threshold'] = lambda row: params['zscore_entry'] - row['ATR_shifted'] * 0.5
            engine.mode_config['pca_stat_arb']['exit_conditions']['zscore_reversion']['threshold'] = params['zscore_exit']
            engine.mode_config['pca_stat_arb']['exit_conditions']['profit_target']['threshold'] = params['profit_target']
            engine.mode_config['pca_stat_arb']['exit_conditions']['stop_loss']['threshold'] = params['stop_loss']
            engine.mode_config['pca_stat_arb']['volatility_mult'] = params['volatility_mult']
            engine.mode_config['pca_stat_arb']['position_risk'] = params['position_risk']

        # Run backtest with updated parameters
        engines, _ = run_backtest(df, timeframe)
        if engines is None or strategy_id not in engines:
            logger.error(f"Backtest failed for Strategy {strategy_id} during optimization")
            return -1.0
        
        # Calculate performance metrics
        metrics = calculate_day_metrics(engines[strategy_id].trade_history)
        sharpe = metrics['overall']['sharpe_ratio']
        return sharpe if np.isfinite(sharpe) else -1.0

    # Initialize and run Bayesian optimization
    optimizer = BayesianOptimization(f=evaluate_strategy, pbounds=pbounds, random_state=1)
    optimizer.maximize(init_points=5, n_iter=20)
    
    # Log and print results
    logger.info(f"Best parameters for Strategy {strategy_id}: {optimizer.max['params']}")
    logger.info(f"Best Sharpe Ratio: {optimizer.max['target']:.2f}")
    print(f"Best parameters and Sharpe Ratio for Strategy {strategy_id}:")
    print(optimizer.max)
    
    return optimizer.max  # Return best result for further use

def update_config(base_config, mode, params):
    """Update the mode_config with parameters (kept for potential future use)."""
    config = base_config[mode].copy()
    for key, value in params.items():
        if key in ['position_risk', 'volatility_mult']:
            config[key] = value
        elif key == 'entry_conditions':
            for cond, cond_params in value.items():
                config['entry_conditions'][cond]['threshold'] = cond_params['threshold']
        elif key == 'exit_conditions':
            for cond, cond_params in value.items():
                for param, val in cond_params.items():
                    config['exit_conditions'][cond][param] = val
        elif key == 'signal_weights':
            for sig, weight in value.items():
                config['signal_weights'][sig] = weight
    return config

# =====================
# LOGGING SETUP
# =====================
class TradeFormatter(logging.Formatter):
    GREEN = '\033[92m'
    RED = '\033[91m'
    WHITE = '\033[0m'
    
    def format(self, record):
        message = super().format(record)
        if sys.stdout.isatty():
            if 'BUY' in message:
                message = f"{self.GREEN}{message}{self.WHITE}"
            elif 'SELL' in message:
                message = f"{self.RED}{message}{self.WHITE}"
        return message

log_file = 'strategy_execution.log'
with open(log_file, 'w') as f:
    f.truncate(0)

root_logger = logging.getLogger()
root_logger.setLevel(logging.INFO)
for handler in root_logger.handlers[:]:
    root_logger.removeHandler(handler)

console_handler = logging.StreamHandler()
console_handler.setFormatter(TradeFormatter('%(asctime)s | %(message)s'))
file_handler = logging.FileHandler(log_file)
file_handler.setFormatter(logging.Formatter('%(asctime)s | %(message)s'))
root_logger.addHandler(console_handler)
root_logger.addHandler(file_handler)
logger = logging.getLogger(__name__)

class GlobalConfig:
    nest_asyncio.apply()
    symbol = 'MSFT'
    durationStr = '7 D'
    timeframes = ['5 mins']
    currency = 'USD'
    initial_balance = 10000
    MIN_REQUIRED_BANDS = 2
    gradient_levels = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]
    colors = ['#FF0000', '#FFA500', '#00FF00', '#0000FF']
    outer_levels = ['weak', 'moderate', 'strong']
    volatility_threshold = 0.05
    MIN_PRICE = 5.0
    MAX_PRICE = 1000.0
    MIN_TRADE_VALUE = 10.0
    MODE_TO_ID = {
        'bollinger_reversion': 'A',
        'pca_stat_arb': 'B'
    }
    STRATEGIES = {
        'A': 'bollinger_reversion',
        'B': 'pca_stat_arb'
    }
    STRATEGY_LABELS = {
        'A': 'A: Bollinger Bands MR',
        'B': 'B: Stat Arb MR',
        'buy_and_hold': 'Benchmark: Buy & Hold'
    }

sns.set_style("whitegrid")
sns.set_context("notebook")
sns.set_palette("tab10")
plt.rcParams.update({
    'font.size': 10,
    'axes.labelcolor': 'black',
    'axes.titlepad': 12,
    'grid.color': 'gray',
    'figure.dpi': 300,
    'axes.facecolor': 'white',
    'figure.facecolor': 'white'
})

MRC_GRADIENT_STYLE = 'full_spectrum'
full_spectrum_colors = ['#FF0000', '#FFA500', '#00FF00', '#0000FF']
def create_colormap(colors_list):
    return LinearSegmentedColormap.from_list('custom_mrc', colors_list, N=len(GlobalConfig.gradient_levels))
full_spectrum_cmap = create_colormap(full_spectrum_colors)
mrc_cmap = full_spectrum_cmap

# =====================
# MARKET REGIME DETECTION
# =====================
def detect_market_regime(row):
    """Detect market regime based on indicators."""
    adx = row['adx_shifted']
    atr_volatility = row['ATR_shifted'] / row['close'] if row['close'] > 0 else 0
    rsi = row['RSI_shifted']
    
    if adx < 25 or atr_volatility < GlobalConfig.volatility_threshold or rsi < 40 or rsi > 60:
        return 'mean_reverting'
    else:
        return 'trending'

# =====================
# MARKET CLOSURE WARNING
# =====================
def enforce_ny_timezone(timestamp):
    ny_tz = pytz.timezone('America/New_York')
    try:
        if not isinstance(timestamp, pd.Timestamp):
            timestamp = pd.to_datetime(timestamp)
        if timestamp.tzinfo is None:
            logger.debug(f"Localizing naive timestamp {timestamp} to NY timezone")
            return ny_tz.localize(timestamp)
        else:
            logger.debug(f"Converting tz-aware timestamp {timestamp} to NY timezone")
            return timestamp.tz_convert(ny_tz)
    except Exception as e:
        logger.error(f"Timezone enforcement failed for {timestamp}: {str(e)}")
        raise ValueError(f"Invalid timestamp: {timestamp}")

def is_market_close(index):
    ny_tz = pytz.timezone('America/New_York')
    if index.tzinfo is None:
        logger.debug(f"Localizing naive index {index} to NY timezone")
        index = index.tz_localize(ny_tz)
    else:
        logger.debug(f"Converting tz-aware index {index} to NY timezone")
        index = index.tz_convert(ny_tz)
    
    current_time = index.time
    market_close_time = time(16, 0)
    time_delta = timedelta(minutes=10)
    
    dummy_date = index.date()
    market_close_dt = ny_tz.localize(datetime.combine(dummy_date, market_close_time))
    
    return (market_close_dt - time_delta) <= index <= market_close_dt

def ensure_ny_timezone(df):
    """Ensure the DataFrame index is in NY timezone."""
    if df.index.tz != pytz.timezone('America/New_York'):
        df.index = df.index.tz_convert('America/New_York')
    return df

# =====================
# METRICS CALCULATION
# =====================
def calculate_day_metrics(trades, risk_free_rate=0.02):
    if not trades:
        logger.warning("No trades provided for metrics calculation")
        return {
            'overall': {
                'win_rate': 0.0,
                'win_loss_ratio': 0.0,
                'num_trades': 0,
                'total_pnl': 0.0,
                'avg_pnl': 0.0,
                'sharpe_ratio': 0.0,
                'sortino_ratio': 0.0,
                'max_drawdown': 0.0,
                'avg_win': 0.0,
                'avg_loss': 0.0,
                'profit_factor': 0.0,
                'avg_holding_hours': 0.0,
                'trades_per_day': 0.0,
                'risk_reward_ratio': 0.0,
                'recovery_factor': 0.0
            },
            'by_exit_strategy': {},
            'holding_periods': {
                'winning': 0.0,
                'losing': 0.0,
                'by_exit_strategy': {}
            },
            'volatility': {
                'avg_atr': 0.0,
                'pnl_volatility_correlation': 0.0
            }
        }

    num_trades = len(trades)
    total_pnl = 0.0
    wins = losses = 0
    pnl_list = []
    win_pnls = []
    loss_pnls = []
    holding_times = []
    exit_strategy_counts = {}
    exit_strategy_pnl = {}
    exit_strategy_wins = {}
    exit_strategy_losses = {}
    exit_strategy_holding = {}
    atr_list = []
    risk_rewards = []
    balance_history = [GlobalConfig.initial_balance]

    for t in trades:
        if not isinstance(t, dict) or 'timestamp' not in t:
            logger.error(f"Invalid trade format: {t}")
            continue
        
        trade_pnl = float(t.get('pnl', 0.0))
        if 'pnl' not in t or t['pnl'] is None:
            logger.warning(f"Trade at {t['timestamp']} missing PnL, defaulting to 0")
        total_pnl += trade_pnl
        pnl_list.append(trade_pnl)
        balance_history.append(balance_history[-1] + trade_pnl)
        
        if t['action'] == 'SELL':
            if trade_pnl > 0:
                wins += 1
                win_pnls.append(trade_pnl)
            elif trade_pnl < 0:
                losses += 1
                loss_pnls.append(trade_pnl)

            entry_time = pd.to_datetime(t.get('entry_time', t['timestamp']))
            exit_time = pd.to_datetime(t['timestamp'])
            holding_time = (exit_time - entry_time).total_seconds() / 3600
            holding_times.append(holding_time)

            exit_type = t.get('exit_type', 'Unknown')
            exit_strategy_counts[exit_type] = exit_strategy_counts.get(exit_type, 0) + 1
            exit_strategy_pnl[exit_type] = exit_strategy_pnl.get(exit_type, 0) + trade_pnl
            if trade_pnl > 0:
                exit_strategy_wins[exit_type] = exit_strategy_wins.get(exit_type, 0) + 1
            elif trade_pnl < 0:
                exit_strategy_losses[exit_type] = exit_strategy_losses.get(exit_type, 0) + 1
            exit_strategy_holding[exit_type] = exit_strategy_holding.get(exit_type, []) + [holding_time]

            if 'ATR' in t and 'entry_price' in t and 'price' in t:
                atr_list.append(float(t['ATR']))
                entry_price = float(t['entry_price'])
                exit_price = float(t['price'])
                potential_loss = abs(entry_price - (entry_price - t['ATR']))
                potential_gain = abs(exit_price - entry_price) if trade_pnl > 0 else 0
                if potential_loss > 0 and potential_gain > 0:
                    risk_rewards.append(potential_gain / potential_loss)

    win_rate = (wins / (wins + losses)) * 100 if (wins + losses) > 0 else 0.0
    win_loss_ratio = (wins / losses) if losses > 0 else float('inf') if wins > 0 else 0.0
    avg_pnl = total_pnl / num_trades if num_trades > 0 else 0.0
    avg_win = sum(win_pnls) / len(win_pnls) if win_pnls else 0.0
    avg_loss = sum(loss_pnls) / len(loss_pnls) if loss_pnls else 0.0
    profit_factor = sum(win_pnls) / abs(sum(loss_pnls)) if loss_pnls and sum(loss_pnls) != 0 else float('inf') if win_pnls else 0.0

    pnl_array = np.array(pnl_list)
    daily_rfr = risk_free_rate / 252
    excess_returns = pnl_array - daily_rfr
    mean_excess_return = np.mean(excess_returns)
    std_dev = np.std(pnl_array, ddof=1) if num_trades > 1 else 0.0
    sharpe_ratio = (mean_excess_return / std_dev) * np.sqrt(252) if std_dev > 0 else 0.0

    downside_returns = pnl_array[pnl_array < 0]
    downside_dev = np.std(downside_returns, ddof=1) if len(downside_returns) > 1 else 0.0
    sortino_ratio = (mean_excess_return / downside_dev) * np.sqrt(252) if downside_dev > 0 else 0.0

    balance_array = np.array(balance_history)
    peak = np.maximum.accumulate(balance_array)
    drawdowns = (peak - balance_array) / peak
    max_drawdown = np.max(drawdowns) * 100 if np.max(drawdowns) > 0 else 0.0

    avg_holding_hours = sum(holding_times) / len(holding_times) if holding_times else 0.0
    days_span = (max(pd.to_datetime([t['timestamp'] for t in trades if t['action'] == 'SELL'])) - 
                 min(pd.to_datetime([t['timestamp'] for t in trades if t['action'] == 'SELL']))).days + 1 if len([t for t in trades if t['action'] == 'SELL']) > 1 else 1
    trades_per_day = len([t for t in trades if t['action'] == 'SELL']) / days_span if days_span > 0 else 0.0
    risk_reward_ratio = sum(risk_rewards) / len(risk_rewards) if risk_rewards and len(risk_rewards) > 0 else 0.0
    recovery_factor = total_pnl / (max_drawdown / 100 * GlobalConfig.initial_balance) if max_drawdown > 0 else float('inf')

    by_exit_strategy = {}
    holding_by_exit = {}
    for exit_type in exit_strategy_counts:
        num_trades_exit = exit_strategy_counts[exit_type]
        wins_exit = exit_strategy_wins.get(exit_type, 0)
        losses_exit = exit_strategy_losses.get(exit_type, 0)
        total_pnl_exit = exit_strategy_pnl[exit_type]
        
        by_exit_strategy[exit_type] = {
            'win_rate': (wins_exit / num_trades_exit * 100) if num_trades_exit > 0 else 0.0,
            'num_trades': num_trades_exit,
            'total_pnl': round(total_pnl_exit, 2),
            'avg_pnl': total_pnl_exit / num_trades_exit if num_trades_exit > 0 else 0.0,
            'win_loss_ratio': (wins_exit / losses_exit) if losses_exit > 0 else float('inf') if wins_exit > 0 else 0.0
        }
        holding_by_exit[exit_type] = sum(exit_strategy_holding[exit_type]) / len(exit_strategy_holding[exit_type]) if exit_strategy_holding[exit_type] else 0.0

    winning_holding = [ht for ht, pnl in zip(holding_times, [t['pnl'] for t in trades if t['action'] == 'SELL']) if pnl > 0]
    losing_holding = [ht for ht, pnl in zip(holding_times, [t['pnl'] for t in trades if t['action'] == 'SELL']) if pnl < 0]
    avg_winning_holding = sum(winning_holding) / len(winning_holding) if winning_holding else 0.0
    avg_losing_holding = sum(losing_holding) / len(losing_holding) if losing_holding else 0.0

    avg_atr = sum(atr_list) / len(atr_list) if atr_list else 0.0
    volatility_pnl_correlation = np.corrcoef(pnl_list, atr_list[:len(pnl_list)])[0, 1] if atr_list and len(pnl_list) <= len(atr_list) else 0.0

    return {
        'overall': {
            'win_rate': round(win_rate, 2),
            'win_loss_ratio': round(win_loss_ratio, 2) if win_loss_ratio != float('inf') else float('inf'),
            'num_trades': num_trades,
            'total_pnl': round(total_pnl, 2),
            'avg_pnl': round(avg_pnl, 2),
            'sharpe_ratio': round(sharpe_ratio, 2),
            'sortino_ratio': round(sortino_ratio, 2),
            'max_drawdown': round(max_drawdown, 2),
            'avg_win': round(avg_win, 2),
            'avg_loss': round(avg_loss, 2),
            'profit_factor': round(profit_factor, 2) if profit_factor != float('inf') else float('inf'),
            'avg_holding_hours': round(avg_holding_hours, 2),
            'trades_per_day': round(trades_per_day, 2),
            'risk_reward_ratio': round(risk_reward_ratio, 2),
            'recovery_factor': round(recovery_factor, 2) if recovery_factor != float('inf') else float('inf')
        },
        'by_exit_strategy': by_exit_strategy,
        'holding_periods': {
            'winning': round(avg_winning_holding, 2),
            'losing': round(avg_losing_holding, 2),
            'by_exit_strategy': {k: round(v, 2) for k, v in holding_by_exit.items()}
        },
        'volatility': {
            'avg_atr': round(avg_atr, 2),
            'pnl_volatility_correlation': round(volatility_pnl_correlation, 2)
        }
    }

# =====================
# BACKTEST ENGINE
# =====================
def is_price_valid(price):
    """Check if the stock price is within acceptable range."""
    return GlobalConfig.MIN_PRICE <= price <= GlobalConfig.MAX_PRICE

def advanced_regime_detection(df):
    features = df[['adx_shifted', 'ATR_shifted', 'RSI_shifted']].dropna()
    kmeans = KMeans(n_clusters=3).fit(features)
    df['regime'] = kmeans.predict(features)
    return df

class BacktestEngine:
    def __init__(self, strategy_id, mode, timeframe='5 mins'):
        self.strategy_id = strategy_id
        self.mode = mode
        self.timeframe = timeframe
        self.mode_config = {
            'bollinger_reversion': {
                'position_risk': 0.02,
                'volatility_mult': 1.5,
                'entry_conditions': {
                    'bollinger_zscore': {'threshold': -2.5, 'operator': '<'},
                    'band_width': {'threshold': 0.05, 'operator': '>'},
                    'volume_spike': {'threshold': 1.5, 'operator': '>'}
                },
                'exit_conditions': {
                    'mean_reversion': {'threshold': lambda row: min(0.5, row['ATR_shifted'] * 1.0), 'operator': '>'},  # Relaxed to 0.5 or ATR
                    'stop_loss': {'threshold': -0.015, 'operator': '<'},
                    'trailing_stop': {'atr_multiplier': 1.0}  # Tightened to 1.0x ATR
                }
            },
            'pca_stat_arb': {
                'position_risk': 0.02,
                'volatility_mult': 1.0,
                'num_equities': 20,
                'rebalance_days': 30,
                'entry_conditions': {
                    'zscore': {'threshold': lambda row: -1.5 - row['ATR_shifted'] * 0.5, 'operator': '<'},
                    'regime': {'threshold': 'mean_reverting', 'operator': '=='}
                },
                'exit_conditions': {
                    'zscore_reversion': {'threshold': -0.5, 'operator': '>'},  # Relaxed from 0.0 to -0.5
                    'profit_target': {'threshold': 0.5, 'operator': '>'},  # Relaxed from 1.0 to 0.5
                    'stop_loss': {'threshold': -2.5, 'operator': '<'}
                }
            }
        }
        self.validate_mode_config()
        self.balance = GlobalConfig.initial_balance
        self.current_positions = []
        self.trade_history = []
        self.fee_per_share = 0.0035
        self.slippage = 0.0002
        self.volatility_filter = {'min_mrc': 0.02, 'max_mrc': 0.08}
        self.daily_pnl = {}
        self.backtest_data = []
        logger.info(f"Strategy {strategy_id} ({mode}) initialized for {timeframe} with balance: ${self.balance}")

    def validate_mode_config(self):
        required_keys = ['position_risk', 'volatility_mult', 'entry_conditions', 'exit_conditions']
        signal_score_required = required_keys + ['signal_weights']
        for mode, config in self.mode_config.items():
            if mode == 'signal_score':
                if not all(k in config for k in signal_score_required):
                    raise ValueError(f"Missing config keys in {mode}: {set(signal_score_required) - set(config.keys())}")
            else:
                if not all(k in config for k in required_keys):
                    raise ValueError(f"Missing config keys in {mode}: {set(required_keys) - set(config.keys())}")

    @property
    def max_position_size(self):
        return self.balance * 0.02

    def calculate_position_size(self, row):
        config = self.mode_config[self.mode]
        active_positions = len(self.current_positions)
        
        metrics = calculate_day_metrics(self.trade_history)
        drawdown_factor = max(0.5, 1 - metrics['overall']['max_drawdown'] / 50)  # Reduce size if drawdown > 50%
        
        base_risk_capital = self.balance * config['position_risk'] * drawdown_factor
        risk_factor = max(1, active_positions * 0.5)
        risk_capital = base_risk_capital / risk_factor
        
        atr_shifted = max(row.get('ATR_shifted', 0.01), 0.01)  # Ensure minimum ATR
        atr_risk = max(atr_shifted * config['volatility_mult'], 0.01)
        
        volume_ratio = row['volume'] / row['volume_ma_shifted'] if row['volume_ma_shifted'] > 0 else 1.0
        volume_factor = min(max(volume_ratio, 0.5), 2.0)
        
        position_size = (risk_capital / atr_risk) * volume_factor
        position_size = min(self.max_position_size, position_size)
        position_size = max(position_size, GlobalConfig.MIN_TRADE_VALUE)
        
        if atr_shifted < 0.01:  # Avoid low-volatility trades
            logger.warning(f"Strategy {self.strategy_id}: ATR too low ({atr_shifted:.4f}), skipping trade")
            return 0
        
        logger.debug(f"Strategy {self.strategy_id} - Position size: ${position_size:.2f} (Drawdown Factor={drawdown_factor:.2f})")
        return position_size

    def apply_slippage(self, price, is_buy, row):
        spread = (row['high'] - row['low']) * 0.5
        return price * (1 + (spread / price) if is_buy else -(spread / price))

    def calculate_fees(self, shares):
        return abs(shares * self.fee_per_share)

    def composite_signal_score(self, row):
        config = self.mode_config[self.mode]
        if self.mode != 'signal_score':
            return 0.0
        weights = config['signal_weights'].copy()
        total_weight = sum(weights.values())
        scores = {}
        conditions_met = 0
        total_conditions = len(weights)

        if 'mean_deviation' in weights:
            deviation = (row['close'] - row['meanline']) / row['meanrange_shifted'] if row['meanrange_shifted'] > 0 else 0
            scores['mean_deviation'] = weights['mean_deviation'] * min(1.0, max(0, (-deviation - 1.0) / 1.0))
            conditions_met += 1 if deviation < -1.0 else 0
        if 'rsi' in weights:
            rsi = row['RSI_shifted']
            scores['rsi'] = weights['rsi'] * min(1.0, max(0, (30 - rsi) / 30))
            conditions_met += 1 if rsi < 30 else 0
        if 'williams' in weights:
            williams = row['Williams_%R_shifted']
            scores['williams'] = weights['williams'] * min(1.0, max(0, (-80 - williams) / 20))
            conditions_met += 1 if williams < -80 else 0

        weighted_score = sum(scores.values()) / total_weight if total_weight > 0 else 0
        return weighted_score if conditions_met >= total_conditions * 0.75 else 0

    def execute_trade(self, price, shares, action, timestamp, exit_type=None, row=None, position=None):
        if not is_price_valid(price):
            logger.warning(f"Strategy {self.strategy_id}: Price ${price:.2f} outside allowed range "
                        f"(${GlobalConfig.MIN_PRICE}-${GlobalConfig.MAX_PRICE})")
            return None

        metrics = calculate_day_metrics(self.trade_history)
        if metrics['overall']['max_drawdown'] > 20:
            logger.error(f"Strategy {self.strategy_id}: Max drawdown exceeded. Halting.")
            return None

        if action == 'BUY' and len(self.current_positions) >= 5:
            logger.warning(f"Strategy {self.strategy_id}: Max positions (5) reached, skipping buy")
            return None

        try:
            price_with_slippage = price
            if row is not None:
                if 'high' in row and 'low' in row and not pd.isna(row['high']) and not pd.isna(row['low']):
                    spread = (row['high'] - row['low']) * 0.5
                    spread_factor = spread / price
                    spread_factor = min(max(spread_factor, -0.1), 0.1)  # Limit to Â±10%
                    price_with_slippage = price * (1 + spread_factor if action == 'BUY' else 1 - spread_factor)
                    logger.debug(f"Strategy {self.strategy_id}: Slippage applied - Price={price:.2f}, Spread={spread:.2f}, Adjusted Price={price_with_slippage:.2f}")
                else:
                    logger.warning(f"Strategy {self.strategy_id}: Missing high/low in row, skipping slippage")
                    price_with_slippage = price
            
            if not np.isfinite(price_with_slippage) or price_with_slippage <= 0:
                logger.error(f"Strategy {self.strategy_id}: Invalid price_with_slippage: {price_with_slippage}")
                return None
            
            # Adjust shares to ensure position_value respects max_position_size after slippage
            if action == 'BUY':
                position_size = self.calculate_position_size(row)  # Recalculate to ensure freshness
                shares = max(0.01, round(position_size / price_with_slippage, 2))
            
            fees = self.calculate_fees(shares)
            position_value = shares * price_with_slippage

            if not np.isfinite(position_value) or position_value <= 0:
                logger.error(f"Strategy {self.strategy_id}: Invalid position value ${position_value:.2f} (shares={shares}, price_with_slippage={price_with_slippage})")
                return None
            
            if action == 'BUY' and position_value < GlobalConfig.MIN_TRADE_VALUE:
                logger.warning(f"Strategy {self.strategy_id}: Position value ${position_value:.2f} below min ${GlobalConfig.MIN_TRADE_VALUE} for BUY")
                return None

            trade = {
                'strategy_id': self.strategy_id,
                'timestamp': timestamp,
                'action': action,
                'price': price_with_slippage,
                'shares': shares,
                'position_value': position_value,
                'balance_before': self.balance,
                'exit_type': exit_type if action == 'SELL' else None
            }

            if action == 'BUY':
                total_cost = position_value + fees
                if total_cost > self.balance:
                    logger.warning(f"Strategy {self.strategy_id}: Insufficient funds: ${total_cost:.2f} > ${self.balance:.2f}")
                    return None
                if position_value > self.max_position_size:  # This should now be rare due to share adjustment
                    logger.warning(f"Strategy {self.strategy_id}: Adjusted position value ${position_value:.2f} still exceeds max ${self.max_position_size:.2f}, scaling down")
                    shares = max(0.01, round(self.max_position_size / price_with_slippage, 2))
                    position_value = shares * price_with_slippage
                    total_cost = position_value + fees
                    if total_cost > self.balance:
                        logger.warning(f"Strategy {self.strategy_id}: Insufficient funds after scaling: ${total_cost:.2f} > ${self.balance:.2f}")
                        return None
                
                position_id = len(self.current_positions)
                self.current_positions.append({
                    'position_id': position_id,
                    'symbol': GlobalConfig.symbol,
                    'entry_price': price_with_slippage,
                    'shares': shares,
                    'timestamp': timestamp,
                    'position_value': position_value,
                    'entry_time': timestamp,
                    'highest_price': price_with_slippage
                })
                self.balance -= total_cost
                trade['pnl'] = 0.0
                trade['pnl_pct'] = 0.0
                trade['entry_time'] = timestamp
                trade['position_id'] = position_id
                logger.info(f"Strategy {self.strategy_id} - Buy: Position #{position_id}, Price=${price_with_slippage:.2f}, Shares={shares:.2f}, Value=${position_value:.2f}, Balance After=${self.balance:.2f}")

            elif action == 'SELL':
                if not position:
                    logger.error(f"Strategy {self.strategy_id}: No position provided for sell")
                    return None
                logger.debug(f"Strategy {self.strategy_id}: Before sell, positions={len(self.current_positions)}, removing Pos #{position['position_id']}")
                if position not in self.current_positions:
                    logger.error(f"Strategy {self.strategy_id}: Position #{position['position_id']} not in current_positions: {self.current_positions}")
                    return None
                self.current_positions.remove(position)
                entry_price = position['entry_price']
                entry_time = position['entry_time']
                entry_value = entry_price * shares
                exit_value = price_with_slippage * shares
                pnl = exit_value - entry_value - fees
                if not np.isfinite(pnl):
                    logger.error(f"Strategy {self.strategy_id}: Invalid PnL calculated: {pnl} (entry_value={entry_value}, exit_value={exit_value}, fees={fees})")
                    pnl = 0.0
                pnl_pct = (pnl / entry_value) * 100 if entry_value != 0 else 0
                trade['pnl'] = pnl
                trade['pnl_pct'] = pnl_pct
                trade['entry_time'] = entry_time
                trade['position_id'] = position['position_id']
                trade['Profit_Outcome'] = 1 if pnl > 0 else 0
                self.balance += (exit_value - fees)
                self.daily_pnl[timestamp.strftime('%Y-%m-%d')] = (
                    self.daily_pnl.get(timestamp.strftime('%Y-m-%d'), 0) + pnl
                )
                logger.info(f"Strategy {self.strategy_id} - Sell: Position #{position['position_id']}, Entry=${entry_price:.2f}, Exit=${price_with_slippage:.2f}, Shares={shares:.2f}, PnL=${pnl:.2f}, Profit_Outcome={trade['Profit_Outcome']}, Balance After=${self.balance:.2f}")

            trade['balance_after'] = self.balance
            if row is not None:
                trade.update(row.to_dict())
            self.trade_history.append(trade)
            self.backtest_data.append(trade)
            return trade
        except Exception as e:
            logger.error(f"Strategy {self.strategy_id} trade execution failed: {str(e)}", exc_info=True)
            return None

    def compute_pca_zscores(self, df, row):
        lookback = 78 * 30  # 30 days at 5-min bars
        if len(df) < lookback:
            return 0.0
        
        history = df.iloc[-lookback:].copy()
        history['returns'] = history['close'].pct_change().fillna(0)
        history['rsi_scaled'] = (history['RSI_shifted'] - 50) / 50
        history['volume_scaled'] = history['volume'] / history['volume_ma_shifted'] - 1
        history['macd_scaled'] = history['MACD_shifted'] / history['ATR_shifted']  # New feature
        
        features = history[['returns', 'rsi_scaled', 'volume_scaled', 'macd_scaled']].fillna(0)
        pca = PCA(n_components=1)
        factors = pca.fit_transform(features)
        
        X = sm.add_constant(factors)
        model = sm.OLS(history['close'], X).fit()
        residuals = model.resid
        zscore = (residuals.iloc[-1] - residuals.mean()) / residuals.std(ddof=1)
        return zscore

# =====================
# CONDITION CHECKS
# =====================
def check_exit_conditions(df, index, engine, row):
    if str(index.tz) != 'America/New_York':
        raise ValueError(f"Invalid timezone in exit check: {index.tz}")
    
    if not engine.current_positions:
        return None
    
    try:
        config = engine.mode_config[engine.mode]
        conditions = config['exit_conditions']
        current_time = enforce_ny_timezone(index)
        current_price = row['close']
        meanrange = row.get('meanrange_shifted', 0) or 1
        
        for pos in engine.current_positions[:]:
            entry_time = pos['entry_time']
            entry_price = pos['entry_price']
            deviation = (current_price - entry_price) / entry_price
            logger.debug(f"Checking exit for Pos #{pos['position_id']} at {index}: Entry=${entry_price:.2f}, Current=${current_price:.2f}, Deviation={deviation:.2%}")
            
            # Add detailed logging of key indicators
            bollinger_std_shifted = row.get('bollinger_std_shifted', 1) or 1
            bollinger_mid_shifted = row.get('bollinger_mid_shifted', current_price)
            bollinger_deviation = (current_price - bollinger_mid_shifted) / bollinger_std_shifted
            atr = row.get('ATR_shifted', 1) or 1
            zscore = engine.compute_pca_zscores(df, row) if engine.mode == 'pca_stat_arb' else 0.0
            logger.debug(f"Strategy {engine.strategy_id}: ATR={atr:.2f}, Bollinger Deviation={bollinger_deviation:.2f}, Z-Score={zscore:.2f}")
            
            for condition_name, params in conditions.items():
                # Handle conditions with 'threshold' key
                if 'threshold' in params:
                    threshold = params['threshold'] if isinstance(params['threshold'], (int, float)) else params['threshold'](row) if callable(params['threshold']) else params['threshold']
                
                if condition_name == 'mean_reversion' and engine.mode == 'bollinger_reversion':
                    if abs(bollinger_deviation) < abs(threshold):
                        logger.info(f"Triggered {condition_name} exit for Pos #{pos['position_id']}: Deviation={bollinger_deviation:.2f} < {threshold:.2f}")
                        return f'Bollinger Mean Reversion (Pos #{pos["position_id"]})'
                    logger.debug(f"No {condition_name} exit for Pos #{pos['position_id']}: Deviation={bollinger_deviation:.2f}, Threshold={threshold:.2f}")
                
                elif condition_name == 'stop_loss':
                    if deviation < threshold:
                        logger.info(f"Triggered {condition_name} exit for Pos #{pos['position_id']}: Deviation={deviation:.2%} < {threshold:.2%}")
                        return f'Stop Loss (Pos #{pos["position_id"]})'
                    logger.debug(f"No {condition_name} exit for Pos #{pos['position_id']}: Deviation={deviation:.2%}, Threshold={threshold:.2%}")
                
                elif condition_name == 'trailing_stop' and engine.mode == 'bollinger_reversion':
                    if 'highest_price' not in pos:
                        pos['highest_price'] = entry_price
                    pos['highest_price'] = max(pos['highest_price'], current_price)
                    stop_level = pos['highest_price'] - (atr * params['atr_multiplier'])
                    if current_price <= stop_level:
                        logger.info(f"Triggered {condition_name} exit for Pos #{pos['position_id']}: Price={current_price:.2f} <= Stop={stop_level:.2f}")
                        return f'Trailing Stop ({params["atr_multiplier"]}x ATR, Pos #{pos["position_id"]})'
                    logger.debug(f"No {condition_name} exit for Pos #{pos['position_id']}: Price={current_price:.2f}, Highest={pos['highest_price']:.2f}, Stop={stop_level:.2f}")
                
                elif condition_name == 'zscore_reversion' and engine.mode == 'pca_stat_arb':
                    if zscore > threshold:
                        logger.info(f"Triggered {condition_name} exit for Pos #{pos['position_id']}: Z-Score={zscore:.2f} > {threshold}")
                        return f'Z-Score Reversion (Pos #{pos["position_id"]})'
                    logger.debug(f"No {condition_name} exit for Pos #{pos['position_id']}: Z-Score={zscore:.2f}, Threshold={threshold}")
                
                elif condition_name == 'profit_target' and engine.mode == 'pca_stat_arb':
                    if zscore > threshold:
                        logger.info(f"Triggered {condition_name} exit for Pos #{pos['position_id']}: Z-Score={zscore:.2f} > {threshold}")
                        return f'Profit Target (Pos #{pos["position_id"]})'
                    logger.debug(f"No {condition_name} exit for Pos #{pos['position_id']}: Z-Score={zscore:.2f}, Threshold={threshold}")
        
        return None
    
    except Exception as e:
        logger.error(f"Strategy {engine.strategy_id} - Error in exit check at {index}: {str(e)}", exc_info=True)
        return None

def check_all_entry_conditions(df, index, engines, row):
    if str(index.tz) != 'America/New_York':
        raise ValueError(f"Invalid timezone in entry check: {index.tz}")
    
    conditions_results = {}
    log_details = [f"Unified Entry Check at {index}"]
    
    all_conditions = set()
    for engine in engines.values():
        all_conditions.update(engine.mode_config[engine.mode]['entry_conditions'].keys())
    
    try:
        meanline = row['meanline']
        meanrange = max(row['meanrange_shifted'], 1e-6)
        volatility = row['ATR_shifted'] / row['close'] if row['close'] > 0 else float('inf')
        
        if row['meanrange_shifted'] <= 0:
            logger.warning(f"Meanrange_shifted <= 0 at {index}, using epsilon: {row['meanrange_shifted']}")
        
        regime = detect_market_regime(row)
        conditions_results['regime'] = regime
        log_details.append(f"Regime: {regime}")
        
        if 'mean_deviation' in all_conditions:
            deviation = (row['close'] - meanline) / meanrange
            conditions_results['mean_deviation'] = deviation
            log_details.append(f"Mean Deviation: {deviation:.2f}")
        
        if 'rsi' in all_conditions:
            rsi_value = row['RSI_shifted']
            conditions_results['rsi'] = rsi_value
            log_details.append(f"RSI: {rsi_value:.2f}")
        
        if 'williams_r' in all_conditions:
            williams_value = row['Williams_%R_shifted']
            conditions_results['williams_r'] = williams_value
            log_details.append(f"Williams %R: {williams_value:.2f}")
        
        if 'atr_breakout' in all_conditions:
            prev_high = df.loc[:index, 'high'].iloc[-2] if len(df.loc[:index]) > 1 else row['high']
            breakout_level = prev_high + row['ATR_shifted']
            atr_breakout = row['close'] > breakout_level
            conditions_results['atr_breakout'] = {'value': row['close'] - breakout_level, 'base_level': breakout_level}
            log_details.append(f"ATR Breakout Base: Close={row['close']:.2f}, Base Level={breakout_level:.2f}")
        
        if 'zscore' in all_conditions:
            for strat_id, engine in engines.items():
                if engine.mode == 'pca_stat_arb':
                    zscore = engine.compute_pca_zscores(df, row)
                    conditions_results['zscore'] = zscore
                    log_details.append(f"PCA Z-Score: {zscore:.2f}")
                    break
        
        if 'bollinger_zscore' in all_conditions:
            zscore = row['bollinger_zscore_shifted']
            conditions_results['bollinger_zscore'] = zscore
            log_details.append(f"Bollinger Z-Score: {zscore:.2f}")
        
        if 'band_width' in all_conditions:  # Added for Strategy A
            band_width = ((row['bollinger_upper_shifted'] - row['bollinger_lower_shifted']) / row['close']) / \
                         max(row['ATR_shifted'] / row['close'] if row['close'] > 0 else 0.01, 0.01)
            conditions_results['band_width'] = band_width
            log_details.append(f"Bollinger Band Width: {band_width:.2f}")
        
        if 'volume_spike' in all_conditions:  # Added for Strategy A
            volume_spike = row['volume'] / row['volume_ma_shifted'] if row['volume_ma_shifted'] > 0 else 0
            conditions_results['volume_spike'] = volume_spike
            log_details.append(f"Volume Spike: {volume_spike:.2f}")
        
        if 'price_divergence' in all_conditions:
            divergence = row['price_divergence_shifted']
            conditions_results['price_divergence'] = divergence
            log_details.append(f"Price Divergence: {divergence:.4f}")
        
        if 'volume' in all_conditions:
            volume_condition = row['volume'] / row['volume_ma_shifted'] if row['volume_ma_shifted'] > 0 else 0
            conditions_results['volume'] = volume_condition
            log_details.append(f"Volume Ratio: {volume_condition:.2f}")
        
        conditions_results['position_ok'] = {strat_id: engine.balance > 1000 
                                            for strat_id, engine in engines.items()}
        conditions_results['time_ok'] = not is_market_close(index)
        log_details.append(f"Time OK: {conditions_results['time_ok']}")
        
        logger.debug(" | ".join(log_details))
        return conditions_results
    
    except Exception as e:
        logger.error(f"Error in unified entry check at {index}: {str(e)}", exc_info=True)
        return {}

def evaluate_strategy_entry(strat_id, engine, conditions_results, row):
    config = engine.mode_config[engine.mode]
    conditions = config['entry_conditions']
    total_conditions = len(conditions) + 3  # Regime, price_valid, time_ok/position_ok
    conditions_met = 0
    
    log_details = [f"Strategy {strat_id} Eval at {row.name}"]
    
    current_price = row['close']
    price_valid = is_price_valid(current_price)
    conditions_met += 1 if price_valid else 0
    log_details.append(f"Price Valid (${current_price:.2f}): {price_valid}")
    if not price_valid:
        logger.debug(f"Strategy {strat_id}: Price ${current_price:.2f} outside allowed range "
                    f"(${GlobalConfig.MIN_PRICE}-${GlobalConfig.MAX_PRICE})")
    
    regime = conditions_results.get('regime', 'unknown')
    conditions_met += 1 if regime == 'mean_reverting' else 0  # Common requirement for both strategies
    log_details.append(f"Regime Mean-Reverting: {regime == 'mean_reverting'}")
    
    for condition_name, params in conditions.items():
        if condition_name not in conditions_results:
            continue
        value = conditions_results.get(condition_name)
        condition_met = False
        
        threshold = params['threshold'] if isinstance(params['threshold'], (int, float)) else params['threshold'](row) if callable(params['threshold']) else params['threshold']
        
        if condition_name == 'mean_deviation':
            condition_met = value < threshold if not pd.isna(value) else False
        elif condition_name == 'rsi':
            condition_met = value < threshold if not pd.isna(value) else False
        elif condition_name == 'williams_r':
            condition_met = value < threshold if not pd.isna(value) else False
        elif condition_name == 'volume':
            condition_met = value > threshold if not pd.isna(value) else False
        elif condition_name == 'zscore':  # Strategy B
            condition_met = value < threshold if not pd.isna(value) else False
        elif condition_name == 'bollinger_zscore':  # Strategy A
            condition_met = value < threshold if not pd.isna(value) else False
        elif condition_name == 'band_width':  # Strategy A
            condition_met = value > threshold if not pd.isna(value) else False
        elif condition_name == 'volume_spike':  # Strategy A
            condition_met = value > threshold if not pd.isna(value) else False
        elif condition_name == 'regime':  # Strategy B
            condition_met = value == threshold if value is not None else False
        elif condition_name == 'price_divergence':
            condition_met = value < threshold if not pd.isna(value) else False
        
        conditions_met += 1 if condition_met else 0
        log_details.append(f"{condition_name}: Met={condition_met} (Value={value}, Threshold={threshold})")
    
    position_ok = conditions_results.get('position_ok', {}).get(strat_id, False)
    time_ok = conditions_results.get('time_ok', False)
    conditions_met += 1 if position_ok and time_ok else 0
    
    fraction_met = conditions_met / total_conditions
    log_details.append(f"Fraction Met: {conditions_met}/{total_conditions} ({fraction_met:.2%})")
    logger.debug(" | ".join(log_details))
    
    return fraction_met >= 0.75

# =====================
# DATA AND INDICATORS
# =====================
def log_trade(trade):
    strategy_id = trade['strategy_id']
    timestamp = pd.to_datetime(trade['timestamp']).tz_convert('America/New_York')
    log_parts = [
        f"#[{strategy_id}] {trade['action'].ljust(6)} | {GlobalConfig.symbol.ljust(5)}",
        f"Time:  {timestamp.strftime('%Y-%m-%d %H:%M:%S%z')}",
        f"Price: ${trade['price']:7.2f}",
        f"Size:  ${trade['position_value']:7.2f}",
        f"Shares: {trade['shares']:>6.2f}"
    ]
    if trade['action'] == 'SELL':
        if 'pnl' not in trade or trade['pnl'] is None:
            logger.error(f"Trade missing PnL: {trade}")
            trade['pnl'] = 0.0
        if 'Profit_Outcome' not in trade:
            trade['Profit_Outcome'] = 1 if trade['pnl'] > 0 else 0
        log_parts.extend([
            f"PnL:   ${trade['pnl']:7.2f}",
            f"Return: {trade['pnl_pct']:6.2f}%",
            f"Profit_Outcome: {trade['Profit_Outcome']}",
            f"Exit:  {trade['exit_type']}"
        ])
        logger.info(f"Trade PnL Validation: {trade['pnl']:.2f} for Position #{trade['position_id']}, Profit_Outcome: {trade['Profit_Outcome']}")
    logger.info(" | ".join(log_parts))

def calculate_mrc_with_gradient(df, length=50, gradient_levels=GlobalConfig.gradient_levels, outer_levels=GlobalConfig.outer_levels):
    df = df.copy()
    
    if 'hlc3' not in df.columns:
        df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3

    df['prev_close'] = df['close'].shift(1).ffill()
    df['tr1'] = df['high'] - df['low']
    df['tr2'] = abs(df['high'] - df['prev_close'])
    df['tr3'] = abs(df['low'] - df['prev_close'])
    df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
    df.drop(['tr1', 'tr2', 'tr3', 'prev_close'], axis=1, inplace=True, errors='ignore')
    tr_mean = df['tr'].mean()
    tr_std = df['tr'].std()
    if tr_std > 0:
        df['tr'] = df['tr'].clip(tr_mean - 3 * tr_std, tr_mean + 3 * tr_std)

    df['meanline'] = supersmoother(df['hlc3'], length, apply_savgol=False).replace([np.inf, -np.inf, np.nan], np.nan).ffill().bfill()
    df['meanrange'] = df['tr'].rolling(10, min_periods=1).mean().replace([np.inf, -np.inf, np.nan], 0).ffill().bfill()
    meanrange_mean = df['meanrange'].mean()
    meanrange_std = df['meanrange'].std()
    if meanrange_std > 0:
        df['meanrange'] = df['meanrange'].clip(meanrange_mean - 3 * meanrange_std, meanrange_mean + 3 * meanrange_std)

    for level in gradient_levels:
        df[f'upband_{level}'] = df['meanline'] + (df['meanrange'] * level)
        df[f'loband_{level}'] = df['meanline'] - (df['meanrange'] * level)
        df[f'upband_{level}_shifted'] = df[f'upband_{level}'].shift(1).ffill().bfill()
        df[f'loband_{level}_shifted'] = df[f'loband_{level}'].shift(1).ffill().bfill()

    outer_multiples = {'weak': 3.0, 'moderate': 3.5, 'strong': 4.0}
    for level_name in outer_levels:
        multiple = outer_multiples[level_name]
        df[f'upband_{level_name}'] = df['meanline'] + (df['meanrange'] * multiple)
        df[f'loband_{level_name}'] = df['meanline'] - (df['meanrange'] * multiple)

    df['meanrange_shifted'] = df['meanrange'].shift(1).ffill().bfill()
    return df

def supersmoother(src: pd.Series, length: int = 50, apply_savgol: bool = False) -> pd.Series:
    if len(src) < 3 or length < 1:
        return src.ffill().bfill()
    
    src_clean = src.copy()
    mean_val = src_clean.mean()
    std_val = src_clean.std()
    if std_val > 0:
        src_clean = src_clean.clip(mean_val - 3 * std_val, mean_val + 3 * std_val)

    a1 = np.exp(-np.sqrt(2) * np.pi / length)
    b1 = 2 * a1 * np.cos(np.sqrt(2) * np.pi / length)
    c3 = -a1**2
    c2 = b1
    c1 = 1 - c2 - c3
    
    ss = np.zeros_like(src_clean, dtype=float)
    ss[0] = src_clean.iloc[0] if not pd.isna(src_clean.iloc[0]) else 0
    ss[1] = src_clean.iloc[1] if not pd.isna(src_clean.iloc[1]) else ss[0]
    for i in range(2, len(src_clean)):
        ss[i] = c1 * (src_clean.iloc[i] if not pd.isna(src_clean.iloc[i]) else ss[i-1]) + c2 * ss[i-1] + c3 * ss[i-2]
    
    result = pd.Series(ss, index=src_clean.index).replace([np.inf, -np.inf, np.nan], np.nan).ffill().bfill()
    
    if apply_savgol and len(result) >= 5:
        window_length = 5 if len(result) >= 5 else len(result)
        if window_length % 2 == 0:
            window_length += 1
        polyorder = 1
        try:
            result = pd.Series(savgol_filter(result, window_length=window_length, polyorder=polyorder), index=result.index)
        except ValueError as e:
            logger.warning(f"Savitzky-Golay filter failed: {str(e)}. Using raw supersmoother result.")
    
    if result.isna().any():
        result = result.interpolate(method='linear', limit=2).ffill().bfill()
    
    return result

def williams_r(high, low, close, lookback=14):
    highest_high = high.rolling(window=lookback, min_periods=1).max()
    lowest_low = low.rolling(window=lookback, min_periods=1).min()
    denominator = highest_high - lowest_low
    denominator = denominator.replace(0, np.nan)
    wr = -100 * ((highest_high - close) / denominator)
    return wr.fillna(-50).replace([np.inf, -np.inf], -50)

def stochastic_oscillator(df, k_period=14, d_period=3):
    low_min = df['low'].rolling(k_period).min()
    high_max = df['high'].rolling(k_period).max()
    df['%K'] = 100 * ((df['close'] - low_min) / (high_max - low_min))
    df['%K'] = df['%K'].fillna(50)
    df['%D'] = df['%K'].rolling(d_period).mean()
    return df

def calculate_point_in_time_indicators(df, index):
    try:
        row = df.loc[index].copy()
        for col in ['open', 'high', 'low', 'close', 'volume', 'hlc3', 'tr']:
            if col in row:
                row[col] = pd.to_numeric(row[col], errors='coerce')
        return row
    except KeyError:
        logger.warning(f"No data available at index {index}")
        return pd.Series()

def calculate_buy_and_hold(df, initial_balance=GlobalConfig.initial_balance, fee_per_share=0.0035):
    try:
        if df.empty or 'close' not in df.columns:
            logger.error("Invalid DataFrame for Buy & Hold calculation")
            return None

        df = ensure_ny_timezone(df.copy())
        
        buy_price = df['close'].iloc[0]
        sell_price = df['close'].iloc[-1]
        
        shares = max(1, round((initial_balance - (initial_balance * fee_per_share)) / buy_price, 0))
        buy_cost = shares * buy_price + (shares * fee_per_share)
        sell_value = shares * sell_price - (shares * fee_per_share)
        
        total_pnl = sell_value - buy_cost
        pnl_pct = (total_pnl / buy_cost) * 100 if buy_cost > 0 else 0.0
        
        trade_history = [
            {
                'strategy_id': 'buy_and_hold',
                'timestamp': df.index[0],
                'action': 'BUY',
                'price': buy_price,
                'shares': shares,
                'position_value': shares * buy_price,
                'pnl': 0.0,
                'entry_time': df.index[0]
            },
            {
                'strategy_id': 'buy_and_hold',
                'timestamp': df.index[-1],
                'action': 'SELL',
                'price': sell_price,
                'shares': shares,
                'position_value': shares * sell_price,
                'pnl': total_pnl,
                'pnl_pct': pnl_pct,
                'entry_time': df.index[0],
                'exit_type': 'End of Period'
            }
        ]
        
        metrics = calculate_day_metrics(trade_history)
        logger.info(f"Buy & Hold - Buy Price: ${buy_price:.2f}, Sell Price: ${sell_price:.2f}, Shares: {shares}, PnL: ${total_pnl:.2f}")
        return {'metrics': metrics, 'final_balance': initial_balance + total_pnl}
    except Exception as e:
        logger.error(f"Error in Buy & Hold calculation: {str(e)}", exc_info=True)
        return None

def get_historical_data(ib, timeframe, exchange='SMART', currency='USD', backtest=False):
    max_retries = 3
    try:
        contract = Stock(GlobalConfig.symbol, exchange, currency)
        ib.qualifyContracts(contract)
        if backtest:
            logger.info(f"Requesting historical data for {GlobalConfig.symbol} at {timeframe}")
            for attempt in range(max_retries):
                try:
                    bars = ib.reqHistoricalData(
                        contract,
                        endDateTime='',
                        durationStr=GlobalConfig.durationStr,
                        barSizeSetting=timeframe,
                        whatToShow='TRADES',
                        useRTH=True,
                        formatDate=2,
                        keepUpToDate=False
                    )
                    if not bars:
                        raise ValueError("No data received from IBKR")
                    break
                except Exception as e:
                    logger.error(f"Attempt {attempt + 1} failed for {timeframe}: {str(e)}")
                    if attempt == max_retries - 1:
                        logger.error(f"Failed to fetch data for {timeframe} after {max_retries} attempts")
                        return None
                    sleep(2)

            df = util.df(bars)
            if df.empty:
                logger.error(f"Empty DataFrame received from IBKR for {timeframe}")
                return None

            df['date'] = pd.to_datetime(df['date'], utc=True)
            df.set_index('date', inplace=True)
            df.index = df.index.tz_convert('America/New_York')

            required_cols = ['open', 'high', 'low', 'close', 'volume']
            for col in required_cols:
                if col not in df.columns:
                    logger.error(f"Missing required column for {timeframe}: {col}")
                    return None
                df[col] = pd.to_numeric(df[col], errors='coerce')
                if df[col].isna().all():
                    logger.error(f"Column {col} contains only NaN values for {timeframe}")
                    return None
                col_mean = df[col].mean()
                col_std = df[col].std()
                if col_std > 0:
                    df[col] = df[col].clip(col_mean - 3 * col_std, col_mean + 3 * col_std)
                df[col] = df[col].interpolate(method='linear', limit=2).ffill().bfill()

            df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3
            df['tr'] = df[['high', 'low', 'close']].apply(
                lambda x: max(x['high'] - x['low'],
                              abs(x['high'] - df['close'].shift().bfill().loc[x.name]),
                              abs(x['low'] - df['close'].shift().bfill().loc[x.name])), axis=1)
            return df
        return None
    except Exception as e:
        logger.error(f"Error in get_historical_data for {timeframe}: {str(e)}", exc_info=True)
        return None

def calculate_adx(df, window=14):
    high = df['high']
    low = df['low']
    close = df['close']
    tr = np.maximum(high - low, np.maximum(np.abs(high - close.shift().bfill()), np.abs(low - close.shift().bfill())))
    up_move = high.diff()
    down_move = -low.diff()
    tr_smooth = tr.ewm(alpha=1/window, adjust=False).mean()
    plus_dm = up_move.where((up_move > down_move) & (up_move > 0), 0.0)
    minus_dm = down_move.where((down_move > up_move) & (down_move > 0), 0.0)
    plus_di = 100 * (plus_dm.ewm(alpha=1/window, adjust=False).mean() / tr_smooth)
    minus_di = 100 * (minus_dm.ewm(alpha=1/window, adjust=False).mean() / tr_smooth)
    di_diff = np.abs(plus_di - minus_di)
    di_sum = (plus_di + minus_di).replace(0, 1e-8)
    dx = 100 * (di_diff / di_sum)
    adx = dx.ewm(alpha=1/window, adjust=False).mean().clip(0, 100)
    df['adx'] = adx
    df['+di'] = plus_di
    df['-di'] = minus_di
    df['adx_shifted'] = adx.shift(1).fillna(0)
    return df

def calculate_rsi(close, period=14):
    delta = close.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss.replace(0, np.inf)
    return 100 - (100 / (1 + rs)).fillna(50)

def calculate_bollinger_bands(df, window=20, num_std=2):
    df = df.copy()
    
    df['bollinger_mid'] = df['close'].rolling(window=window, min_periods=1).mean()
    df['bollinger_std'] = df['close'].rolling(window=window, min_periods=1).std()
    df['bollinger_upper'] = df['bollinger_mid'] + (df['bollinger_std'] * num_std)
    df['bollinger_lower'] = df['bollinger_mid'] - (df['bollinger_std'] * num_std)
    df['bollinger_zscore'] = (df['close'] - df['bollinger_mid']) / df['bollinger_std'].replace(0, np.nan).fillna(0)
    
    shifted_cols = ['bollinger_mid', 'bollinger_std', 'bollinger_upper', 'bollinger_lower', 'bollinger_zscore']
    for col in shifted_cols:
        df[f'{col}_shifted'] = df[col].shift(1).fillna(df[col].iloc[0] if not df[col].empty else 0)
    
    return df

def calculate_bollinger_width(row):
    """Calculate Bollinger Band width relative to ATR."""
    band_width = (row['bollinger_upper_shifted'] - row['bollinger_lower_shifted']) / row['close']
    atr_normalized = row['ATR_shifted'] / row['close'] if row['close'] > 0 else 0.01
    return band_width / max(atr_normalized, 0.01)  # Avoid division by zero

def print_backtest_report(metrics, bar_size, strategy_name):
    print(f"\n=== {strategy_name} Performance Report - {bar_size} ===")
    print("\nOverall Metrics:")
    for key, value in metrics['overall'].items():
        print(f"  {key.replace('_', ' ').title()}: {value if value != float('inf') else 'â'}")

    print("\nPerformance by Exit Strategy:")
    for strategy, stats in metrics['by_exit_strategy'].items():
        print(f"  {strategy}:")
        for key, value in stats.items():
            print(f"    {key.replace('_', ' ').title()}: {value if value != float('inf') else 'â'}")

    print("\nHolding Periods (hours):")
    print(f"  Winning Trades: {metrics['holding_periods']['winning']}")
    print(f"  Losing Trades: {metrics['holding_periods']['losing']}")
    print("  By Exit Strategy:")
    for strategy, hours in metrics['holding_periods']['by_exit_strategy'].items():
        print(f"    {strategy}: {hours}")

    print("\nVolatility Metrics:")
    print(f"  Average ATR: {metrics['volatility']['avg_atr']}")
    print(f"  PnL-Volatility Correlation: {metrics['volatility']['pnl_volatility_correlation']}")

def execute_entry(strategy_id, engine, price, timestamp, position_size, row):
    timestamp = enforce_ny_timezone(pd.to_datetime(timestamp))
    shares = max(0.01, round(position_size / price, 2))
    if not np.isfinite(shares):
        logger.error(f"Strategy {strategy_id}: Invalid share calculation: Shares={shares}")
        return None
    trade = engine.execute_trade(price=price, shares=shares, action='BUY', timestamp=timestamp, row=row)
    if trade:
        log_trade(trade)
    return trade

def execute_exit(strategy_id, engine, price, timestamp, exit_type, row):
    if not engine.current_positions:
        logger.warning(f"Strategy {strategy_id}: Exit attempted with no positions")
        return None
    timestamp = enforce_ny_timezone(pd.to_datetime(timestamp))
    if not exit_type or 'Pos #' not in exit_type:
        logger.error(f"Strategy {strategy_id}: Invalid exit_type format: {exit_type}")
        return None
    try:
        pos_id = int(exit_type.split('Pos #')[1].strip(')'))
    except (IndexError, ValueError) as e:
        logger.error(f"Strategy {strategy_id}: Failed to parse pos_id from exit_type '{exit_type}': {str(e)}")
        return None
    position = next((p for p in engine.current_positions if p['position_id'] == pos_id), None)
    if not position:
        logger.warning(f"Strategy {strategy_id}: Position #{pos_id} not found for exit in {engine.current_positions}")
        return None
    exit_shares = position['shares']
    logger.debug(f"Strategy {strategy_id}: Attempting exit for Pos #{pos_id}, Shares={exit_shares}, Price={price}")
    trade = engine.execute_trade(price=price, shares=exit_shares, action='SELL', timestamp=timestamp, exit_type=exit_type, row=row, position=position)
    if trade:
        log_trade(trade)
    else:
        logger.error(f"Strategy {strategy_id}: Failed to execute exit trade for Pos #{pos_id}")
    return trade

def run_backtest(df, timeframe, collect_non_trades=False):
    try:
        if df is None or df.empty:
            logger.error(f"Invalid input data for backtest at {timeframe}")
            return None, None
        logger.info(f"Starting optimized backtest for {timeframe} with data shape: {df.shape}")

        # Precompute all indicators once
        df = calculate_mrc_with_gradient(df)
        required_indicators = ['tr', 'volume', 'close', 'high', 'low']
        missing = [col for col in required_indicators if col not in df.columns]
        if missing:
            logger.error(f"Missing required columns for indicators: {missing}")
            return None, None

        df['ATR'] = df['tr'].rolling(14, min_periods=1).mean().fillna(0)
        df = calculate_adx(df)
        df = stochastic_oscillator(df)
        df['VWAP'] = (df['hlc3'] * df['volume']).groupby(df.index.date).cumsum() / df['volume'].groupby(df.index.date).cumsum().fillna(df['close'])
        df['MACD'] = df['close'].ewm(span=12, adjust=False).mean() - df['close'].ewm(span=26, adjust=False).mean()
        df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
        df['Histogram'] = df['MACD'] - df['Signal']
        df['RSI'] = calculate_rsi(df['close']).fillna(50)
        df['Williams_%R'] = williams_r(df['high'], df['low'], df['close']).fillna(-50)
        df['volume_ma'] = df['volume'].rolling(20, min_periods=1).mean().fillna(df['volume'].mean())
        df = calculate_bollinger_bands(df)
        df['price_change'] = df['close'].pct_change()
        df['price_divergence_shifted'] = df['price_change'].shift(1).fillna(0)

        shifted_cols = ['close', 'RSI', 'Williams_%R', 'VWAP', 'MACD', 'Signal', 'Histogram', 'adx', '+di', '-di', '%K', '%D', 'volume_ma', 'ATR', 'meanrange', 
                        'bollinger_mid', 'bollinger_upper', 'bollinger_lower', 'bollinger_zscore', 'bollinger_std']
        for col in shifted_cols:
            if col in df.columns:
                df[f'{col}_shifted'] = df[col].shift(1).fillna(df[col].iloc[0])

        # Initialize engines
        engines = {
            'A': BacktestEngine('A', 'bollinger_reversion', timeframe),
            'B': BacktestEngine('B', 'pca_stat_arb', timeframe)
        }

        # Vectorized entry/exit conditions
        df['is_market_open'] = ~df.index.map(is_market_close)
        df['price_valid'] = df['close'].apply(is_price_valid)

        # Ensure no NaN values in critical columns
        for col in ['bollinger_zscore_shifted', 'bollinger_upper_shifted', 'bollinger_lower_shifted', 'close', 'ATR_shifted', 'volume', 'volume_ma_shifted']:
            if col in df.columns:
                df[col] = df[col].fillna(0)

        # Strategy A: Bollinger Reversion
        config_a = engines['A'].mode_config['bollinger_reversion']
        df['entry_a'] = (
            (df['bollinger_zscore_shifted'] < config_a['entry_conditions']['bollinger_zscore']['threshold']) &
            ((df['bollinger_upper_shifted'] - df['bollinger_lower_shifted']) / df['close'] / (df['ATR_shifted'] / df['close']).clip(lower=0.01) > config_a['entry_conditions']['band_width']['threshold']) &
            (df['volume'] / df['volume_ma_shifted'] > config_a['entry_conditions']['volume_spike']['threshold']) &
            df['is_market_open'] & df['price_valid']
        )
        df['exit_a_mean'] = df['close'].shift(-1) > df['bollinger_mid_shifted']  # Simplified mean reversion
        df['exit_a_stop'] = (df['close'].shift(-1) - df['close']) / df['close'] < config_a['exit_conditions']['stop_loss']['threshold']

        # Strategy B: PCA Stat Arb
        config_b = engines['B'].mode_config['pca_stat_arb']
        df['zscore'] = df.apply(lambda row: engines['B'].compute_pca_zscores(df, row), axis=1)
        df['regime'] = df.apply(detect_market_regime, axis=1)
        df['entry_b'] = (
            (df['zscore'] < config_b['entry_conditions']['zscore']['threshold'](df.iloc[-1])) &
            (df['regime'] == 'mean_reverting') &
            df['is_market_open'] & df['price_valid']
        )
        df['exit_b_zscore'] = df['zscore'].shift(-1) > config_b['exit_conditions']['zscore_reversion']['threshold']

        # Process trades in bulk
        for strat_id, engine in engines.items():
            entry_col = f'entry_{strat_id.lower()}'
            positions = []
            trade_history = []

            for idx, row in df[df[entry_col]].iterrows():
                if len(positions) < 5:  # Max positions
                    position_size = engine.calculate_position_size(row)
                    if position_size > 0:
                        trade = engine.execute_trade(row['close'], position_size / row['close'], 'BUY', idx, row=row)
                        if trade:
                            positions.append(trade)
                            trade_history.append(trade)

            # Exit logic (simplified for speed)
            for pos in positions[:]:
                pos_idx = df.index.get_loc(pos['timestamp'])
                for i in range(pos_idx + 1, len(df)):
                    row = df.iloc[i]
                    exit_type = check_exit_conditions(df, row.name, engine, row)
                    if exit_type:
                        trade = engine.execute_trade(row['close'], pos['shares'], 'SELL', row.name, exit_type, row=row, position=pos)
                        if trade:
                            trade_history.append(trade)
                            positions.remove(pos)
                        break
                    elif i == len(df) - 1:  # Forced exit
                        trade = engine.execute_trade(row['close'], pos['shares'], 'SELL', row.name, f"Forced Exit (Pos #{pos['position_id']})", row=row, position=pos)
                        if trade:
                            trade_history.append(trade)
                            positions.remove(pos)

            engine.trade_history = trade_history
            logger.info(f"Strategy {strat_id} completed - Trades: {len(trade_history)}")

        return engines, df
    except Exception as e:
        logger.error(f"Error in run_backtest: {str(e)}", exc_info=True)
        return None, None

# =====================
# MAIN EXECUTION
# =====================
def main():
    ib = IB()
    max_retries = 3
    try:
        logger.setLevel(logging.DEBUG)
        logger.info("Starting main execution with Bollinger Bands MR, Stat Arb MR, and Buy & Hold comparison")
        for attempt in range(max_retries):
            try:
                ib.connect('127.0.0.1', 7497, clientId=1)
                logger.info("Connected to IBKR")
                break
            except Exception as e:
                logger.error(f"IB connection attempt {attempt + 1} failed: {str(e)}")
                if attempt == max_retries - 1:
                    raise
                sleep(2)

        all_results = {}

        # Initial backtest for all timeframes
        for timeframe in GlobalConfig.timeframes:
            logger.info(f"Processing timeframe: {timeframe}")
            daily_data = get_historical_data(ib, timeframe, backtest=True)
            if daily_data is None or len(daily_data) < 2:
                logger.error(f"Failed or insufficient data for {timeframe}, skipping")
                continue
            
            engines, daily_data = run_backtest(daily_data, timeframe)
            if engines is None:
                logger.error(f"Backtest failed for {timeframe}, skipping")
                continue

            trade_histories = {strat_id: engine.trade_history for strat_id, engine in engines.items()}
            metrics = {}
            for strat_id, trades in trade_histories.items():
                strat_name = GlobalConfig.STRATEGY_LABELS[strat_id]
                metrics[strat_name] = calculate_day_metrics(trades)
                print(f"\n=== {strat_name} Final Stats for {timeframe} TF ===")
                print(f"# of Trades: {len(trades)}")
                print(f"Final Balance: ${engines[strat_id].balance:.2f}")
                print_backtest_report(metrics[strat_name], timeframe, strat_name)

            if not any(len(trades) > 0 for trades in trade_histories.values()):
                logger.error(f"No trades executed for any strategy in {timeframe}, skipping comparison")
                continue

            selected_strategies = {
                'A: Bollinger Bands MR': metrics['A: Bollinger Bands MR'],
                'B: Stat Arb MR': metrics['B: Stat Arb MR']
            }

            buy_hold_result = calculate_buy_and_hold(daily_data)
            if buy_hold_result:
                selected_strategies['Benchmark: Buy & Hold'] = buy_hold_result['metrics']
                print(f"\n=== Buy & Hold Final Stats for {timeframe} TF ===")
                print(f"# of Trades: 2 (Buy & Sell)")
                print(f"Final Balance: ${buy_hold_result['final_balance']:.2f}")
                print_backtest_report(buy_hold_result['metrics'], timeframe, "Buy & Hold")

            all_results[timeframe] = {
                'engines': engines,
                'metrics': selected_strategies,
                'data': daily_data
            }

        # Optimize all strategies for each timeframe
        optimized_results = {}
        for timeframe, result in all_results.items():
            for strat_id in ['A', 'B']:  # Optimize both strategies
                optimized_result = optimize_strategy(result['data'], timeframe, strat_id)
                if optimized_result:
                    optimized_results[f"{strat_id}_{timeframe}"] = optimized_result
                    # Optionally apply optimized parameters to engines
                    engine = result['engines'][strat_id]
                    if strat_id == 'A':
                        engine.mode_config['bollinger_reversion']['entry_conditions']['bollinger_zscore']['threshold'] = optimized_result['params']['zscore']
                        engine.mode_config['bollinger_reversion']['entry_conditions']['band_width']['threshold'] = optimized_result['params']['band_width']
                        engine.mode_config['bollinger_reversion']['entry_conditions']['volume_spike']['threshold'] = optimized_result['params']['volume_spike']
                        engine.mode_config['bollinger_reversion']['exit_conditions']['mean_reversion']['threshold'] = lambda row: optimized_result['params']['mean_reversion']
                        engine.mode_config['bollinger_reversion']['exit_conditions']['stop_loss']['threshold'] = optimized_result['params']['stop_loss']
                        engine.mode_config['bollinger_reversion']['exit_conditions']['trailing_stop']['atr_multiplier'] = optimized_result['params']['trailing_atr']
                    elif strat_id == 'B':
                        engine.mode_config['pca_stat_arb']['entry_conditions']['zscore']['threshold'] = lambda row: optimized_result['params']['zscore_entry'] - row['ATR_shifted'] * 0.5
                        engine.mode_config['pca_stat_arb']['exit_conditions']['zscore_reversion']['threshold'] = optimized_result['params']['zscore_exit']
                        engine.mode_config['pca_stat_arb']['exit_conditions']['profit_target']['threshold'] = optimized_result['params']['profit_target']
                        engine.mode_config['pca_stat_arb']['exit_conditions']['stop_loss']['threshold'] = optimized_result['params']['stop_loss']
                        engine.mode_config['pca_stat_arb']['volatility_mult'] = optimized_result['params']['volatility_mult']
                        engine.mode_config['pca_stat_arb']['position_risk'] = optimized_result['params']['position_risk']
                    # Re-run backtest with optimized parameters
                    engines_opt, _ = run_backtest(result['data'], timeframe)
                    if engines_opt and strat_id in engines_opt:
                        optimized_metrics = calculate_day_metrics(engines_opt[strat_id].trade_history)
                        print(f"\n=== Optimized {GlobalConfig.STRATEGY_LABELS[strat_id]} Stats for {timeframe} TF ===")
                        print_backtest_report(optimized_metrics, timeframe, f"Optimized {GlobalConfig.STRATEGY_LABELS[strat_id]}")

        # Summary
        if all_results:
            print("\n=== Multi-Timeframe Backtest Summary ===")
            results_list = []
            for timeframe, result in all_results.items():
                for strat_name, strat_metrics in result['metrics'].items():
                    results_list.append({
                        'bar_size': timeframe,
                        'strategy': strat_name,
                        'total_pnl': strat_metrics['overall']['total_pnl'],
                        'sharpe_ratio': strat_metrics['overall']['sharpe_ratio'],
                        'profit_factor': strat_metrics['overall']['profit_factor'],
                        'num_trades': strat_metrics['overall']['num_trades'],
                        'win_rate': strat_metrics['overall']['win_rate'],
                        'max_drawdown': strat_metrics['overall']['max_drawdown'],
                        'avg_holding_hours': strat_metrics['overall']['avg_holding_hours']
                    })
            results_df = pd.DataFrame(results_list)
            if not results_df.empty:
                best_pnl = results_df.loc[results_df['total_pnl'].idxmax()]
                print(f"\nBest Total PnL: {best_pnl['strategy']} on {best_pnl['bar_size']}")
                print(f"  Total PnL: ${best_pnl['total_pnl']:.2f}")
                print(f"  Sharpe Ratio: {best_pnl['sharpe_ratio']:.2f}")
                print(f"  Profit Factor: {best_pnl['profit_factor']:.2f}")

    except Exception as e:
        logger.error(f"Main execution error: {str(e)}", exc_info=True)
    finally:
        if ib.isConnected():
            ib.disconnect()
            logger.info("Disconnected from IBKR")

if __name__ == '__main__':
    main()
