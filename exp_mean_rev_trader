# =====================
# CORE IMPORTS
# =====================
from ib_insync import *
import pandas as pd
import numpy as np
import mplfinance as mpf
from datetime import datetime, timedelta, time
import asyncio
import nest_asyncio
import logging
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from time import sleep
from matplotlib.colors import ListedColormap, Normalize, LinearSegmentedColormap
from collections.abc import MutableMapping
import pytz
import re
import matplotlib.patheffects as pe
from matplotlib.cm import ScalarMappable
import seaborn as sns

# =====================
# GLOBAL CONFIGURATION
# =====================

class GlobalConfig():
    nest_asyncio.apply()
GlobalConfig.symbol = 'MSFT'
currency = 'USD'  # Explicitly set currency
initial_balance = 10000
MIN_REQUIRED_BANDS = 2
gradient_levels = [0.5, 1.0, 1.5, 2.0]
colors = ['#FF0000', '#FFA500', '#00FF00', '#0000FF']  # Hot (red) to cold (blue) spectrum

# Configure plot style
sns.set_style("whitegrid")
sns.set_context("notebook")
sns.set_palette("tab10")
plt.rcParams.update({
    'font.size': 10,
    'axes.labelcolor': 'black',
    'axes.titlepad': 12,
    'grid.color': 'gray',
    'figure.dpi': 300,
    'axes.facecolor': 'white',
    'figure.facecolor': 'white'
})

# MRC Gradient Style Options
MRC_GRADIENT_STYLE = 'full_spectrum'  # Fixed to full spectrum (hot-cold)

# Custom color maps for different gradient styles
full_spectrum_colors = ['#FF0000', '#FFA500', '#00FF00', '#0000FF']  # Hot (red) to cold (blue) spectrum

# Create color maps
def create_colormap(colors_list):
    return LinearSegmentedColormap.from_list('custom_mrc', colors_list, N=len(gradient_levels))

full_spectrum_cmap = create_colormap(full_spectrum_colors)
mrc_cmap = full_spectrum_cmap  # Use full spectrum as default

# =====================
# LINKED LIST DICTIONARY IMPLEMENTATION
# =====================
class LLNode:
    __slots__ = ('key', 'value', 'next')
    def __init__(self, key, value, next=None):
        self.key = key
        self.value = value
        self.next = next

class LLDict(MutableMapping):
    def __init__(self):
        self.head = None
        self._size = 0

    def __setitem__(self, key, value):
        current = self.head
        while current is not None:
            if current.key == key:
                current.value = value
                return
            current = current.next
        self.head = LLNode(key, value, self.head)
        self._size += 1

    def __getitem__(self, key):
        current = self.head
        while current is not None:
            if current.key == key:
                return current.value
            current = current.next
        raise KeyError(key)

    def __delitem__(self, key):
        prev = None
        current = self.head
        while current is not None:
            if current.key == key:
                if prev:
                    prev.next = current.next
                else:
                    self.head = current.next
                self._size -= 1
                return
            prev = current
            current = current.next
        raise KeyError(key)

    def __iter__(self):
        current = self.head
        while current is not None:
            yield current.key
            current = current.next

    def __len__(self):
        return self._size

# =====================
# MARKET CLOSURE WARNING
# =====================
def is_market_close(index):
    ny_tz = pytz.timezone('America/New_York')
    if index.tz is None:
        index = index.tz_localize(ny_tz)
    else:
        index = index.tz_convert(ny_tz)
    
    current_time = index.time
    market_close_time = time(16, 0)
    time_delta = timedelta(minutes=10)
    
    dummy_date = index.date()
    market_close_dt = ny_tz.localize(datetime.combine(dummy_date, market_close_time))
    
    return (market_close_dt - time_delta) <= index <= market_close_dt

# =====================
# PNL CALENDAR
# =====================
def plot_pnl_calendar(engine, start_date, end_date, initial_balance, symbol):
    ny_tz = pytz.timezone('America/New_York')
    trade_df = pd.DataFrame(engine.trade_history)
    
    if not trade_df.empty and 'timestamp' in trade_df.columns:
        trade_df['timestamp'] = pd.to_datetime(trade_df['timestamp']).dt.tz_convert(ny_tz)
        start_date = trade_df['timestamp'].min().normalize()
        end_date = trade_df['timestamp'].max().normalize()
    else:
        logger.warning("No trades available for calendar")
        return

    current_date = start_date.normalize()
    while current_date <= end_date:
        next_month = current_date.replace(day=1) + pd.DateOffset(months=1)
        month_end = min(next_month - pd.Timedelta(days=1), end_date)
        all_dates = pd.date_range(start=current_date, end=month_end, freq='D', tz=ny_tz)

        daily_pnl = pd.DataFrame.from_dict(engine.daily_pnl, orient='index', columns=['pnl'])
        daily_pnl.index = pd.to_datetime(daily_pnl.index).tz_convert(ny_tz)
        daily_pnl = daily_pnl.reindex(all_dates, fill_value=0).reset_index()
        daily_pnl.rename(columns={'index': 'date'}, inplace=True)

        fig, ax = plt.subplots(figsize=(16, 28))
        ax.set_facecolor('white')
        
        first_day_of_month = current_date.replace(day=1)
        first_day_offset = first_day_of_month.weekday()
        days_in_month = (current_date + pd.offsets.MonthEnd(1)).day
        num_weeks = ((days_in_month + first_day_offset - 1) // 7) + 1

        for i, row in daily_pnl.iterrows():
            date = row['date']
            col = date.weekday()
            day_of_month = date.day
            week_num = (day_of_month + first_day_offset - 1) // 7
            row_pos = -week_num

            if col in [5, 6]:
                color = '#000000'
                ax.add_patch(plt.Rectangle((col, row_pos), 1, 1, facecolor=color, edgecolor='gray', lw=0.5))
            else:
                day_trades = trade_df[trade_df['timestamp'].dt.date == date.date()].to_dict('records')
                metrics = calculate_day_metrics(day_trades)
                
                if metrics['num_trades'] == 0:
                    color = '#d3d3d3'
                else:
                    max_abs_pnl = abs(daily_pnl['pnl']).max()
                    color_intensity = min(1, abs(row['pnl']) / max_abs_pnl) if max_abs_pnl > 0 else 0
                    color = f"#{int((0.8 - color_intensity) * 255):02x}ff{int((0.8 - color_intensity) * 255):02x}"

                ax.add_patch(plt.Rectangle((col, row_pos), 1, 1, facecolor=color, edgecolor='gray', lw=0.5))
                ax.text(col + 0.05, row_pos + 0.85, str(day_of_month), ha='left', va='top', fontsize=8, color='black')
                ax.text(col + 0.5, row_pos + 0.5,
                        f"${row['pnl']:.2f}\nW%: {metrics['win_rate']:.2f}%\nTrades: {metrics['num_trades']}",
                        ha='center', va='center', fontsize=6, color='black')

        ax.set_xlim(-0.5, 6.5)
        ax.set_ylim(-num_weeks - 0.5, 0.5)
        ax.set_xticks(range(7))
        ax.set_xticklabels(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], color='black')
        ax.set_yticks([])
        plt.suptitle(f"{symbol} Trading Performance {current_date.strftime('%B %Y')}", fontsize=16, color='black')
        plt.tight_layout()
        plt.show()
        current_date = next_month

def calculate_day_metrics(trades):
    num_trades = len(trades)
    wins = losses = pnl = 0.0
    
    for t in trades:
        if not isinstance(t, dict) or 'timestamp' not in t:
            logger.error("Invalid trade format in calculate_day_metrics")
            continue
        trade_pnl = float(t.get('pnl', 0.0))
        pnl += trade_pnl
        if trade_pnl > 0:
            wins += 1
        elif trade_pnl < 0:
            losses += 1
    
    win_rate = (wins / num_trades * 100) if num_trades > 0 else 0.0
    return {
        'win_rate': round(win_rate, 2),
        'win_loss_ratio': (wins / losses) if losses > 0 else float('inf'),
        'num_trades': num_trades,
        'pnl': round(pnl, 2)
    }

# =====================
# BACKTEST ENGINE
# =====================
class BacktestEngine:
    def __init__(self, mode='neutral'):
        self.mode = mode
        self.mode_config = {
            'aggressive': {'rsi_entry': 28, 'williams_entry': -85, 'position_risk': 0.03, 'volatility_mult': 1.8, 
                          'profit_target': 1.8, 'stop_loss': 0.96, 'adx_threshold': 22, 'di_ratio': 1.25, 
                          'macd_crossover': 1.15},
            'neutral': {'rsi_entry': 32, 'williams_entry': -80, 'position_risk': 0.02, 'volatility_mult': 1.5, 
                       'profit_target': 1.5, 'stop_loss': 0.94, 'adx_threshold': 25, 'di_ratio': 1.35, 
                       'macd_crossover': 1.05},
            'conservative': {'rsi_entry': 35, 'williams_entry': -75, 'position_risk': 0.01, 'volatility_mult': 1.2, 
                            'profit_target': 1.2, 'stop_loss': 0.92, 'adx_threshold': 28, 'di_ratio': 1.5, 
                            'macd_crossover': 1.0}
        }
        self.validate_mode_config()
        
        self.balance = initial_balance
        self.positions = LLDict()
        self.trade_history = []
        self.current_position = None
        self.fee_per_share = 0.0035
        self.slippage = 0.0002
        self.volatility_filter = {'min_mrc': 0.02, 'max_mrc': 0.05}
        self.daily_pnl = {}
        self.indicator_weights = {
            'rsi': 0.25, 'williams': 0.25, 'macd': 0.2, 'vwap': 0.15, 'adx': 0.1, 'volume': 0.05
        }
        self.adx_params = {
            'mean_reversion_threshold': 25, 'low_volatility_threshold': 15, 'trend_strength_exit': 40,
            'rapid_trend_threshold': 15
        }

    @property
    def max_position_size(self):
        return self.balance * 0.25

    def validate_mode_config(self):
        required_keys = ['rsi_entry', 'williams_entry', 'position_risk', 'volatility_mult', 'profit_target', 
                        'stop_loss', 'adx_threshold', 'di_ratio', 'macd_crossover']
        for mode, config in self.mode_config.items():
            if not all(k in config for k in required_keys):
                raise ValueError(f"Missing config keys in {mode}")

    def calculate_position_size(self, row):
        mp = self.mode_config[self.mode]
        risk_capital = self.balance * mp['position_risk']
        combined_vol = (max(0.01, row['meanrange']) * mp['volatility_mult'] + row['ATR']) / 2
        return min(self.max_position_size, risk_capital / combined_vol)

    def composite_signal_score(self, row):
        """
        Calculate a composite signal score as a percentage (0 to 1) based on how many conditions are met,
        using all indicators with mode-specific thresholds. Trigger a buy if the score exceeds 0.6 (60%).
        """
        volatility_regime = 1 + min(2, (row['ATR'] / row['close']) * 2.5)
        total_weight = sum(self.indicator_weights.values())  # Normalize weights to sum to 1

        scores = {}
        conditions_met = 0
        total_conditions = len(self.indicator_weights) + 2  # Add Stochastic (%K, %D) and DI ratio

        # Mode-specific thresholds
        mode_config = self.mode_config[self.mode]
        rsi_threshold = mode_config['rsi_entry']  # e.g., 28, 32, 35
        williams_threshold = mode_config['williams_entry']  # e.g., -85, -80, -75
        adx_threshold = mode_config['adx_threshold']  # e.g., 22, 25, 28
        macd_crossover = mode_config['macd_crossover']  # e.g., 1.15, 1.05, 1.0
        di_ratio = mode_config['di_ratio']  # e.g., 1.25, 1.35, 1.5

        # RSI (oversold condition)
        if row['RSI_shifted'] < rsi_threshold:
            scores['rsi'] = self.indicator_weights['rsi']
            conditions_met += 1
        else:
            scores['rsi'] = 0

        # Williams %R (oversold condition)
        if row['Williams_%R_shifted'] < williams_threshold:
            scores['williams'] = self.indicator_weights['williams']
            conditions_met += 1
        else:
            scores['williams'] = 0

        # MACD (bearish crossover for mean-reversion)
        if row['MACD_shifted'] < row['Signal_shifted']:
            scores['macd'] = self.indicator_weights['macd']
            conditions_met += 1
        else:
            scores['macd'] = 0

        # VWAP (price below VWAP for mean-reversion)
        if row['VWAP_shifted'] > row['close_shifted']:
            scores['vwap'] = self.indicator_weights['vwap']
            conditions_met += 1
        else:
            scores['vwap'] = 0

        # ADX (low trend strength for mean-reversion)
        if row['adx_shifted'] < adx_threshold:
            scores['adx'] = self.indicator_weights['adx']
            conditions_met += 1
        else:
            scores['adx'] = 0

        # Volume (higher than moving average for confirmation)
        if row['volume'] > row['volume_ma']:
            scores['volume'] = self.indicator_weights['volume']
            conditions_met += 1
        else:
            scores['volume'] = 0

        # Directional Indicators (+DI < -DI * di_ratio for downward pressure)
        if row['+di_shifted'] < row['-di_shifted'] * di_ratio:
            conditions_met += 1  # No weight, counted as an additional condition
        else:
            pass  # No penalty, just not counted

        # Stochastic (%K < %D and %D < 20 for oversold)
        if row['%K_shifted'] < row['%D_shifted'] and row['%D_shifted'] < 20:
            conditions_met += 1  # No weight, counted as an additional condition
        else:
            pass  # No penalty, just not counted

        # Calculate percentage of conditions met, weighted by importance
        weighted_score = sum(scores[k] for k in self.indicator_weights) / total_weight
        percentage_score = (conditions_met / total_conditions) * volatility_regime * weighted_score

        logger.debug(f"Composite signal score at {row.name}: {percentage_score:.2%} "
                     f"(Conditions met: {conditions_met}/{total_conditions})")

        return min(1.0, percentage_score)  # Cap at 100% (1.0)


    def _normalize_macd(self, macd, signal):
        denominator = abs(macd) + abs(signal)
        if denominator < 1e-8:
            return 0
        return (macd - signal) / denominator

    def _dynamic_adx_weight(self, adx, plus_di, minus_di):
        di_diff = abs(plus_di - minus_di)
        trend_strength = max(0, (25 - min(adx, 25)) / 25)
        direction_confidence = 1 - (di_diff / 100)
        return trend_strength * direction_confidence

    def apply_slippage(self, price, is_buy):
        slippage_factor = 1 + (self.slippage if is_buy else -self.slippage)
        return price * slippage_factor
    
    def calculate_fees(self, shares):
        return abs(shares * self.fee_per_share)

    def execute_trade(self, symbol, price, shares, action, timestamp):
        try:
            price_with_slippage = self.apply_slippage(price, action == 'BUY')
            fees = self.calculate_fees(shares)
            position_value = shares * price_with_slippage

            if action == 'BUY':
                if position_value > self.balance:
                    logger.warning(f"Insufficient funds for {symbol}: {position_value} > {self.balance}")
                    return None
                self.current_position = {
                    'symbol': symbol, 'entry_price': price_with_slippage, 'shares': shares, 
                    'timestamp': timestamp, 'position_value': position_value
                }
                self.balance -= (position_value + fees)
            elif action == 'SELL' and self.current_position:
                entry_price = self.current_position['entry_price']
                entry_value = self.current_position['position_value']
                exit_value = position_value
                pnl = exit_value - entry_value - fees
                pnl_pct = (pnl / entry_value) * 100 if entry_value != 0 else 0

                trade = {
                    'symbol': symbol, 'action': action, 'price': price_with_slippage, 'shares': shares,
                    'timestamp': timestamp, 'pnl': pnl, 'pnl_pct': pnl_pct, 'position_value': position_value
                }
                self.balance += (exit_value - fees)
                self.trade_history.append(trade)
                self.daily_pnl[timestamp.strftime('%Y-%m-%d')] = (
                    self.daily_pnl.get(timestamp.strftime('%Y-%m-%d'), 0) + pnl
                )
                self.current_position = None
                return trade

            trade = {
                'symbol': symbol, 'action': action, 'price': price_with_slippage, 'shares': shares,
                'timestamp': timestamp, 'pnl': 0.0, 'pnl_pct': 0.0, 'position_value': position_value
            }
            self.trade_history.append(trade)
            return trade
        except Exception as e:
            logger.error(f"Trade execution failed: {str(e)}")
            return None

# =====================
# TRADE EXECUTION CORE
# =====================
def execute_entry(price, timestamp, position_size):
    timestamp = enforce_ny_timezone(pd.to_datetime(timestamp))
    shares = max(0.01, position_size / price)
    if not np.isfinite(shares):
        logger.error(f"Invalid share calculation: {position_size}/{price}")
        return None
    trade = engine.execute_trade(symbol=symbol, price=price, shares=shares, action='BUY', timestamp=timestamp)
    if trade:
        log_trade(trade, symbol)
        return trade
    return None

def execute_exit(price, timestamp):
    if not engine.current_position:
        logger.warning("Exit attempted with no open position")
        return None
    timestamp = enforce_ny_timezone(pd.to_datetime(timestamp))
    position = engine.current_position
    exit_shares = min(position['shares'], engine.max_position_size)
    trade = engine.execute_trade(symbol=symbol, price=price, shares=exit_shares, action='SELL', timestamp=timestamp)
    if trade:
        log_trade(trade, symbol)
        return trade
    return None

# Initialize engine globally
engine = BacktestEngine()

# =====================
# CONDITION CHECKS
# =====================
def check_entry_conditions(df, index):
    """
    Check conditions for entering a mean-reversion trade (buy signal) using all indicators.
    Trigger a buy if the composite signal score exceeds 60%, using mode-specific thresholds.
    """
    if str(index.tz) != 'America/New_York':
        raise ValueError(f"Invalid timezone in entry check: {index.tz}")
    
    try:
        row = df.loc[index]
        # Debug logging to track values
        logger.debug(f"Checking entry at {index}: Close={row['close_shifted']}, "
                     f"Loband={row[f'loband_{gradient_levels[0]}_shifted']}, "
                     f"Composite Score={engine.composite_signal_score(row):.2%}")

        # Mode-specific thresholds
        mode_config = engine.mode_config[engine.mode]
        rsi_threshold = mode_config['rsi_entry']  # e.g., 28 (aggressive), 32 (neutral), 35 (conservative)
        williams_threshold = mode_config['williams_entry']  # e.g., -85 (aggressive), -80 (neutral), -75 (conservative)
        adx_threshold = mode_config['adx_threshold']  # e.g., 22 (aggressive), 25 (neutral), 28 (conservative)
        macd_crossover = mode_config['macd_crossover']  # e.g., 1.15 (aggressive), 1.05 (neutral), 1.0 (conservative)
        di_ratio = mode_config['di_ratio']  # e.g., 1.25 (aggressive), 1.35 (neutral), 1.5 (conservative)

        # Basic mean-reversion condition: Price below the 0.5 MRC band
        price_below_band = row['close_shifted'] < row[f'loband_{gradient_levels[0]}_shifted']
        
        # Volatility check: Ensure mean range is within acceptable bounds
        volatility_ok = (engine.volatility_filter['min_mrc'] < row['meanrange'] < engine.volatility_filter['max_mrc'])
        
        # Position and capital checks
        position_ok = (
            engine.balance > 1000 and  # Ensure sufficient capital
            not engine.current_position and  # No open position
            volatility_ok
        )
        
        # Market hours check
        time_ok = not is_market_close(index)
        
        # Use composite signal score > 60% to trigger entry, using all indicators
        composite_score = engine.composite_signal_score(row)
        entry_signal = composite_score >= 0.6  # 60% threshold
        
        return price_below_band and entry_signal and position_ok and time_ok
    
    except KeyError as e:
        logger.error(f"Missing data at {index}: {str(e)}")
        return False
    except Exception as e:
        logger.error(f"Error in entry condition check at {index}: {str(e)}")
        return False

def check_exit_conditions(df, index):
    """
    Check conditions for exiting a mean-reversion trade (sell signal) using all indicators.
    Use mode-specific thresholds from the selected trading mode.
    """
    if str(index.tz) != 'America/New_York':
        raise ValueError(f"Invalid timezone in exit check: {index.tz}")
    
    if not engine.current_position:
        return False
    
    try:
        row = df.loc[index]
        entry_price = engine.current_position['entry_price']
        
        # Mode-specific thresholds
        mode_config = engine.mode_config[engine.mode]
        stop_loss_factor = mode_config['stop_loss']  # e.g., 0.96 (aggressive), 0.94 (neutral), 0.92 (conservative)
        profit_target_factor = mode_config['profit_target']  # e.g., 1.8 (aggressive), 1.5 (neutral), 1.2 (conservative)
        adx_threshold_exit = engine.adx_params['trend_strength_exit']  # e.g., 40 (fixed)
        
        # Profit-taking conditions: Exit when price reverses or exceeds targets
        profit_conditions = (
            # Price crosses above SMA_20 (trend reversal or profit)
            (row['close_shifted'] > row['SMA_20_shifted']) or
            # RSI overbought (fixed threshold, but can be mode-specific if needed)
            (row['RSI_shifted'] > 70) or
            # Williams %R indicates overbought (use mode-specific if desired, currently fixed)
            (row['Williams_%R_shifted'] > -20) or
            # Price crosses above VWAP (mean-reversion exit)
            (row['close_shifted'] > row['VWAP_shifted']) or
            # ADX indicates strong trend (exit mean-reversion position)
            (row['adx_shifted'] > adx_threshold_exit) or
            # Upward directional movement (trend shift, using mode-specific DI ratio)
            (row['+di_shifted'] > row['-di_shifted'] * di_ratio) or
            # Stochastic overbought
            (row['%D_shifted'] > 80) or
            # MACD bullish crossover (optional, using mode-specific threshold)
            (row['MACD_shifted'] > row['Signal_shifted'] * macd_crossover) or
            # Profit target (mode-specific)
            (row['close_shifted'] >= entry_price * profit_target_factor)
        )
        
        # Stop-loss conditions: Exit to limit losses or due to high volatility
        stop_loss_conditions = (
            # Price falls below stop-loss level (mode-specific)
            (row['close_shifted'] < entry_price * stop_loss_factor) or
            # Excessive volatility
            (row['meanrange'] > engine.volatility_filter['max_mrc'] * 1.5) or
            # Rapid ADX change indicating volatility spike
            (np.abs(row['adx_shifted'] - row['adx_shifted'].shift(3)) > 15) or
            # Volume spike indicating potential reversal (optional)
            (row['volume'] > row['volume_ma'] * 2)  # Volume doubles the moving average
        )
        
        # Return true if either profit or stop-loss conditions are met
        return profit_conditions or stop_loss_conditions
    
    except KeyError as e:
        logger.error(f"Missing data at {index}: {str(e)}")
        return False
    except Exception as e:
        logger.error(f"Error in exit condition check at {index}: {str(e)}")
        return False

# =====================
# LOGGING SETUP
# =====================
class TradeFormatter(logging.Formatter):
    GREEN = '\033[92m'
    RED = '\033[91m'
    WHITE = '\033[0m'
    
    def format(self, record):
        message = super().format(record)
        message = self.colorize_actions(message)
        message = self.colorize_values(message)
        return message

    def colorize_actions(self, message):
        return re.sub(r'^(BUY|SELL)(\s+\|)', 
                     lambda m: f"{self.GREEN if m.group(1) == 'BUY' else self.RED}{m.group(1)}{self.WHITE}{m.group(2)}",
                     message, count=1)
        
    def colorize_values(self, message):
        def color_repl(match):
            value_str = match.group(1) or match.group(2)
            try:
                value = float(value_str)
                color = self.GREEN if value > 0 else self.RED
            except:
                color = self.WHITE
            return f"{color}{match.group(0)}{self.WHITE}"
        
        parts = message.split(' | ')
        for i, part in enumerate(parts):
            if part.startswith(('Price:', 'Size:')):
                continue
            parts[i] = re.sub(r'\$ *(-?\d+\.\d+)|(-?\d+\.\d+)%', color_repl, part)
        return ' | '.join(parts)

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
for handler in root_logger.handlers[:]:
    root_logger.removeHandler(handler)

console_handler = logging.StreamHandler()
console_handler.setFormatter(TradeFormatter('%(asctime)s | %(message)s'))
file_handler = logging.FileHandler('strategy_execution.log')
file_handler.setFormatter(logging.Formatter('%(asctime)s | %(message)s'))
root_logger.addHandler(console_handler)
root_logger.addHandler(file_handler)
logger = logging.getLogger(__name__)

# =====================
# LOG TRADE FUNCTION
# =====================
def log_trade(trade, symbol):
    try:
        timestamp = pd.to_datetime(trade['timestamp'])
        if timestamp.tz is None:
            timestamp = timestamp.tz_localize('UTC')
        trade_time = timestamp.tz_convert('America/New_York')
        
        log_parts = [
            f"{TradeFormatter.GREEN if trade['action'] == 'BUY' else TradeFormatter.RED}"
            f"{trade['action'].ljust(6)}\033[0m | {symbol.ljust(5)}",
            f"Time:  {trade_time.strftime('%Y-%m-%d %H:%M:%S%z')}",
            f"Price: \033[97m${trade['price']:7.2f}\033[0m",
            f"Size:  \033[97m${trade['position_value']:7.2f}\033[0m",
            f"Shares: \033[97m{trade['shares']:>6.2f}\033[0m"
        ]
        if trade['action'] == 'SELL':
            pnl_color = TradeFormatter.GREEN if trade['pnl'] > 0 else TradeFormatter.RED
            log_parts.extend([
                f"PnL:   {pnl_color}${trade['pnl']:7.2f}{TradeFormatter.WHITE}",
                f"Return: {pnl_color}{trade['pnl_pct']:6.2f}%{TradeFormatter.WHITE}"
            ])
        logger.info(" | ".join(log_parts))
    except Exception as e:
        logger.error(f"Failed to log trade: {str(e)}", exc_info=True)

# =====================
# DATA MANAGEMENT
# =====================
def calculate_mrc_with_gradient(df, length=100, gradient_levels=[0.5, 1.0, 1.5, 2.0]):
    df['prev_close'] = df['close'].shift(1).ffill()
    df['tr1'] = df['high'] - df['low']
    df['tr2'] = abs(df['high'] - df['prev_close'])
    df['tr3'] = abs(df['low'] - df['prev_close'])
    df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
    df.drop(['tr1', 'tr2', 'tr3', 'prev_close'], axis=1, inplace=True, errors='ignore')

    df['meanline'] = supersmoother(df['hlc3'], length).bfill().ffill()
    df['meanrange'] = df['tr'].rolling(20).mean().bfill().ffill()
    
    for level in gradient_levels:
        df[f'upband_{level}'] = df['meanline'] + (df['meanrange'] * level)
        df[f'loband_{level}'] = df['meanline'] - (df['meanrange'] * level)
        df[f'upband_{level}_shifted'] = df[f'upband_{level}'].shift(1).ffill()
        df[f'loband_{level}_shifted'] = df[f'loband_{level}'].shift(1).ffill()
    
    df['meanrange_shifted'] = df['meanrange'].shift(1).ffill()
    return df

def supersmoother(src: pd.Series, length: int) -> pd.Series:
    if len(src) < 3:
        return src.ffill().bfill()
    a1 = np.exp(-np.sqrt(2) * np.pi / length)
    b1 = 2 * a1 * np.cos(np.sqrt(2) * np.pi / length)
    c3 = -a1**2
    c2 = b1
    c1 = 1 - c2 - c3
    
    ss = np.zeros_like(src)
    ss[0] = src.iloc[0]
    ss[1] = src.iloc[1]
    for i in range(2, len(src)):
        ss[i] = c1 * src.iloc[i] + c2 * ss[i-1] + c3 * ss[i-2]
    return pd.Series(ss, index=src.index).bfill().ffill()

def williams_r(high, low, close, lookback=14):
    highest_high = high.rolling(window=lookback, min_periods=1).max()
    lowest_low = low.rolling(window=lookback, min_periods=1).min()
    denominator = (highest_high - lowest_low).replace(0, np.nan)
    wr = -100 * ((highest_high - close) / denominator)
    return wr.fillna(-50)

def stochastic_oscillator(df, k_period=14, d_period=3):
    low_min = df['low'].rolling(k_period).min()
    high_max = df['high'].rolling(k_period).max()
    df['%K'] = 100 * ((df['close'] - low_min) / (high_max - low_min))
    df['%K'] = df['%K'].fillna(50)
    df['%D'] = df['%K'].rolling(d_period).mean()
    return df

def calculate_adx(df, window=14):
    high = df['high']
    low = df['low']
    close = df['close']
    tr = np.maximum(high - low, np.maximum(np.abs(high - close.shift().bfill()), np.abs(low - close.shift().bfill())))
    up_move = high.diff()
    down_move = -low.diff()
    tr_smooth = tr.ewm(alpha=1/window, adjust=False).mean()
    plus_dm = up_move.where((up_move > down_move) & (up_move > 0), 0.0)
    minus_dm = down_move.where((down_move > up_move) & (down_move > 0), 0.0)
    plus_di = 100 * (plus_dm.ewm(alpha=1/window, adjust=False).mean() / tr_smooth)
    minus_di = 100 * (minus_dm.ewm(alpha=1/window, adjust=False).mean() / tr_smooth)
    di_diff = np.abs(plus_di - minus_di)
    di_sum = (plus_di + minus_di).replace(0, 1e-8)
    dx = 100 * (di_diff / di_sum)
    adx = dx.ewm(alpha=1/window, adjust=False).mean().clip(0, 100)
    df['adx'] = adx
    df['+di'] = plus_di
    df['-di'] = minus_di
    df['adx_shifted'] = adx.shift(1).fillna(0)
    return df[['adx', '+di', '-di', 'adx_shifted']]

def get_historical_data(ib, symbol, exchange='SMART', currency='USD', backtest=False):
    contract = Stock(symbol, exchange, currency)
    ib.qualifyContracts(contract)
    if backtest:
        logger.info(f"Requesting historical data for {symbol}")
        bars = ib.reqHistoricalData(
            contract, endDateTime='', durationStr='14 D', barSizeSetting='1 hour',
            whatToShow='TRADES', useRTH=True, formatDate=1, keepUpToDate=False)
        
        if not bars:
            logger.error("No historical data received from IBKR")
            raise ValueError("No historical data received")
        
        df = util.df(bars)
        if df.empty:
            logger.error("Empty DataFrame received from IB")
            raise ValueError("Empty DataFrame received from IB")

        logger.debug(f"Raw DataFrame shape: {df.shape}")
        logger.debug(f"Raw DataFrame columns: {df.columns.tolist()}")
        logger.debug(f"Raw DataFrame index: {df.index}")

        # Use the 'date' column to set the correct index (timestamps in UTC for consistency)
        df['date'] = pd.to_datetime(df['date'], format='%Y%m%d %H:%M:%S %Z').dt.tz_convert('UTC')
        df.set_index('date', inplace=True)
        
        # Ensure all required columns exist and handle missing values
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in required_cols:
            if col not in df.columns:
                df[col] = df['close'].ffill().bfill()
            df[col] = df[col].replace([np.inf, -np.inf, np.nan, 0], np.nan).astype(float).ffill().bfill()
            logger.debug(f"Column {col} first few values: {df[col].head()}")

        df['hlc3'] = (df['high'] + df['low'] + df['close']) / 3
        df = calculate_mrc_with_gradient(df)
        df = df.drop(columns=['average', 'barCount'], errors='ignore')
        
        calculate_adx(df)
        df = stochastic_oscillator(df)
        
        df['vwap_numerator'] = df['volume'] * df['hlc3']
        df['vwap_denominator'] = df['volume']
        df['trading_date'] = df.index.date
        df['VWAP'] = (df.groupby('trading_date')['vwap_numerator'].cumsum() /
                      df.groupby('trading_date')['vwap_denominator'].cumsum())
        
        exp12 = df['close'].ewm(span=12, adjust=False).mean()
        exp26 = df['close'].ewm(span=26, adjust=False).mean()
        df['MACD'] = np.where(np.abs(exp12 - exp26) < 1e-8, 0, exp12 - exp26)
        df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
        df['Histogram'] = df['MACD'] - df['Signal']
        
        delta = df['close'].diff()
        gain = delta.where(delta > 0, 0.0)
        loss = -delta.where(delta < 0, 0.0)
        avg_gain = gain.ewm(alpha=1/14, adjust=False).mean().replace(0, np.nan).fillna(0.01)  # Avoid zero
        avg_loss = loss.ewm(alpha=1/14, adjust=False).mean().replace(0, np.nan).fillna(0.01)  # Avoid zero
        df['RSI'] = 100 - (100 / (1 + (avg_gain / avg_loss).replace(0, np.nan))).fillna(50)  # Handle zero division
        
        df['Williams_%R'] = williams_r(df['high'], df['low'], df['close'])
        df['ATR'] = df['tr'].rolling(14).mean().replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        df['volume_ma'] = df['volume'].rolling(20).mean().replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        df['SMA_20'] = df['close'].rolling(window=20).mean().replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        
        # Clean indicator columns with stricter NaN handling
        indicator_cols = ['MACD', 'Signal', 'Histogram', 'RSI', 'Williams_%R', 'adx', '+di', '-di', '%K', '%D']
        for col in indicator_cols:
            df[col] = df[col].replace([np.inf, -np.inf, np.nan, 0], np.nan).astype(float).ffill().bfill()
            if col in ['+di', '-di']:
                df[col] = df[col].replace(0, np.nan).ffill().bfill()
            logger.debug(f"Indicator column {col} first few values: {df[col].head()}")

        shifted_cols = ['close', 'RSI', 'Williams_%R', 'VWAP', 'MACD', 'Signal', 
                        'adx', '+di', '-di', '%K', '%D', 'volume_ma', 'SMA_20']
        for col in shifted_cols:
            df[f'{col}_shifted'] = df[col].shift(1).replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        for level in gradient_levels:
            df[f'upband_{level}_shifted'] = df[f'upband_{level}'].shift(1).replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
            df[f'loband_{level}_shifted'] = df[f'loband_{level}'].shift(1).replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        
        df = df.drop(['vwap_numerator', 'vwap_denominator', 'trading_date'], axis=1)
        
        logger.debug(f"Final DataFrame shape: {df.shape}")
        logger.debug(f"Final DataFrame columns: {df.columns.tolist()}")
        logger.debug(f"Final DataFrame index: {df.index}")
        logger.info(f"Processed historical data with {len(df)} rows")
        return df

def plot_mrc_gradient(ax, df):
    # Handle NaN values in meanline and bands
    meanline = df['meanline'].replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
    if meanline.empty or meanline.isna().all():
        logger.error("Meanline data is empty or contains only NaN values")
        return
    
    ax.plot(df.index, meanline, color='purple', linestyle='-', linewidth=1.8, zorder=3,
            path_effects=[pe.Stroke(linewidth=3, foreground='white'), pe.Normal()])
    
    norm = Normalize(vmin=min(gradient_levels), vmax=max(gradient_levels))
    for i, level in enumerate(gradient_levels):
        color = mrc_cmap(norm(level))
        upper_band = df[f'upband_{level}'].replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        lower_band = df[f'loband_{level}'].replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill()
        if upper_band.empty or upper_band.isna().all() or lower_band.empty or lower_band.isna().all():
            logger.error(f"Band data for level {level} is empty or contains only NaN values")
            continue
        ax.plot(df.index, upper_band, color=color, linestyle='-' if level != 0.5 else ':', linewidth=1.5, zorder=2,
                alpha=0.8 if level != 0.5 else 0.7)
        ax.plot(df.index, lower_band, color=color, linestyle='-' if level != 0.5 else ':', linewidth=1.5, zorder=2,
                alpha=0.8 if level != 0.5 else 0.7)
    
    ax.plot(df.index, df[f'upband_{gradient_levels[0]}'].replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill(),
            color='cyan', linestyle=':', linewidth=1.5, zorder=2, alpha=0.7)
    ax.plot(df.index, df[f'loband_{gradient_levels[0]}'].replace([np.inf, -np.inf, np.nan, 0], np.nan).ffill().bfill(),
            color='cyan', linestyle=':', linewidth=1.5, zorder=2, alpha=0.7)

    ax.set_xlim(df.index[0], df.index[-1])
    ax.set_ylim(df['close'].min() * 0.95, df['close'].max() * 1.05)  # Adjust y-limits for better visibility

# =====================
# VISUALIZATION ENGINE
# =====================
def plot_candlestick(df, backtest=False, symbol=GlobalConfig.symbol):
    if df.empty:
        logger.error("Cannot plot empty DataFrame")
        raise ValueError("Cannot plot empty DataFrame")
    
    # Ensure index is properly formatted and convert to UTC for mplfinance compatibility
    df.index = pd.to_datetime(df.index).tz_convert('UTC')
    
    # Debug the DataFrame
    logger.debug(f"Plotting DataFrame shape: {df.shape}")
    logger.debug(f"Plotting DataFrame columns: {df.columns.tolist()}")
    logger.debug(f"Plotting DataFrame index: {df.index}")
    logger.debug(f"Sample OHLCV data: {df[['open', 'high', 'low', 'close', 'volume']].head()}")
    logger.debug(f"Data types: {df.dtypes}")
    logger.debug(f"NaN count per column: {df.isna().sum()}")
    logger.debug(f"Zero count per column: {(df == 0).sum()}")

    # Verify index is a DatetimeIndex and timezone-aware (UTC)
    if not isinstance(df.index, pd.DatetimeIndex) or df.index.tz is None:
        logger.error("Invalid DataFrame index format for plotting")
        raise ValueError("DataFrame index must be a timezone-aware DatetimeIndex (UTC)")

    # Check for required columns and handle NaN or infinite values
    required_ohlcv = ['open', 'high', 'low', 'close', 'volume']
    required_indicators = ['MACD', 'Signal', 'Histogram', 'RSI', 'Williams_%R', 'adx', '+di', '-di', '%K', '%D']
    missing_ohlcv = [col for col in required_ohlcv if col not in df.columns]
    missing_indicators = [col for col in required_indicators if col not in df.columns]
    if missing_ohlcv:
        logger.error(f"Missing required OHLCV columns for plotting: {missing_ohlcv}")
        raise ValueError(f"Missing required OHLCV columns: {missing_ohlcv}")
    if missing_indicators:
        logger.warning(f"Missing some indicator columns for plotting: {missing_indicators}")
        # Optionally fill missing indicators with zeros or skip them
        for col in missing_indicators:
            if col not in df.columns:
                df[col] = 0.0  # Default to zero if missing

    # Clean data: ensure numeric and handle NaN/infinite/zero values for OHLCV and indicators
    for col in required_ohlcv + required_indicators:
        df[col] = pd.to_numeric(df[col], errors='coerce').replace([np.inf, -np.inf, 0], np.nan)
        if df[col].isna().any():
            logger.warning(f"Column {col} contains NaN values before filling: {df[col].isna().sum()} NaNs")
            # Use interpolation for OHLCV, and forward/backward fill for indicators
            if col in required_ohlcv:
                df[col] = df[col].interpolate(method='linear').ffill().bfill()
            else:
                df[col] = df[col].ffill().bfill()
        logger.debug(f"Column {col} after cleaning: {df[col].head()}")

    # Create addplots for indicators
    addplots = [
        mpf.make_addplot(df['loband_0.5'], panel=0, color="cyan", linestyle=':', alpha=0.7, label='MRC Low 0.5'),
        mpf.make_addplot(df['upband_0.5'], panel=0, color="cyan", linestyle=':', alpha=0.7, label='MRC High 0.5'),
        mpf.make_addplot(df['MACD'], panel=1, color='#1f77b4', width=1.2, ylabel='MACD'),
        mpf.make_addplot(df['Signal'], panel=1, color='#ff7f0e', width=1.2, label='Signal'),
        mpf.make_addplot(df['Histogram'], type='bar', panel=1,
                        color=np.where(df['Histogram'] >= 0, '#5cb85c', '#D83B2D'), alpha=0.6, width=0.7, label='Histogram'),
        mpf.make_addplot(df['volume'], type='bar', panel=2,
                        color=np.where(df['close'] > df['open'], '#5cb85c', '#d9534f'), alpha=0.6, ylabel='Volume'),
        mpf.make_addplot(df['RSI'], panel=3, color='#4B0082', width=1.2, ylim=(0, 100), ylabel='RSI'),
        mpf.make_addplot(pd.Series(30, index=df.index), panel=3, color='gray', linestyle='--', label='RSI 30'),
        mpf.make_addplot(pd.Series(70, index=df.index), panel=3, color='gray', linestyle='--', label='RSI 70'),
        mpf.make_addplot(df['Williams_%R'], panel=4, color='blue', width=1.2, ylabel='Williams %R', ylim=(-100, 0)),
        mpf.make_addplot(pd.Series(-20, index=df.index), panel=4, color='red', linestyle='--', label='Williams -20'),
        mpf.make_addplot(pd.Series(-80, index=df.index), panel=4, color='green', linestyle='--', label='Williams -80'),
        mpf.make_addplot(df['adx'], panel=5, color='blue', width=1.5, ylabel='ADX/DIs'),
        mpf.make_addplot(df['+di'], panel=5, color='green', width=1.5, alpha=0.75, label='+DI'),
        mpf.make_addplot(df['-di'], panel=5, color='red', width=1.5, alpha=0.75, label='-DI'),
        mpf.make_addplot(df['%K'], panel=6, color='blue', width=1.2, ylabel='Stochastic', ylim=(0, 100)),
        mpf.make_addplot(df['%D'], panel=6, color='orange', width=1.2, label='%D'),
        mpf.make_addplot(pd.Series(20, index=df.index), panel=6, color='green', linestyle='--', label='Stoch 20'),
        mpf.make_addplot(pd.Series(80, index=df.index), panel=6, color='red', linestyle='--', label='Stoch 80'),
    ]
    
    # Define style for consistent appearance
    style = mpf.make_mpf_style(
        marketcolors=mpf.make_marketcolors(up="#00FF00", down="#FF0000", edge='inherit'),
        gridstyle=":", gridcolor="gray", facecolor="white",
        base_mpf_style="classic"
    )
    
    # Plot with mplfinance, ensuring candlesticks and all panels are visible
    try:
        logger.debug("Attempting to plot OHLCV and indicators with mplfinance")
        fig, axlist = mpf.plot(
            df, 
            type='candle',  # Explicitly set to candlestick
            style=style,
            volume=True,  # Ensure volume bars are plotted
            addplot=addplots,  # All additional plots (indicators and MRC)
            panel_ratios=(10, 5, 4, 4, 4, 4, 4),  # 7 panels: candlestick (0), MACD (1), Volume (2), RSI (3), Williams (4), ADX (5), Stochastic (6)
            figsize=(16, 24),
            title=f'{symbol} Candlestick Chart (Backtest: {backtest})',
            xrotation=45,
            returnfig=True
        )
    except Exception as e:
        logger.error(f"Error plotting with mplfinance: {str(e)}")
        raise

    # Plot MRC gradient bands on the main candlestick panel (panel 0)
    main_ax = axlist[0]
    try:
        plot_mrc_gradient(main_ax, df)
    except Exception as e:
        logger.error(f"Error in plot_mrc_gradient: {str(e)}")

    # Enhance axis formatting for all panels
    for ax in axlist:
        ax.grid(True, color='gray', linestyle=':', linewidth=0.5)
        ax.set_facecolor('white')
        ax.tick_params(colors='black', labelsize=8)
        ax.xaxis.label.set_color('black')
        ax.yaxis.label.set_color('black')
        for spine in ax.spines.values():
            spine.set_edgecolor('black')
        
        # Set x-axis formatter for datetime
        from matplotlib.dates import DateFormatter
        ax.xaxis.set_major_locator(plt.MaxNLocator(10))
        ax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d %H:%M'))

    # Add legend to each panel
    for i, ax in enumerate(axlist):
        ax.legend(loc='best', frameon=True, facecolor='white', edgecolor='black', fontsize=8)

    # Remove plt.tight_layout() to avoid warnings and ensure mplfinance handles layout
    logger.info(f"Loaded historical data with {len(df)} rows for plotting")
    plt.show()

    # Check mplfinance version for compatibility
    logger.debug(f"mplfinance version: {mpf.__version__}")

# =====================
# MODE SELECTION
# =====================
def select_trading_mode():
    print("\nSelect Trading Strategy Mode:")
    print("1. Aggressive")
    print("2. Neutral (Default)")
    print("3. Conservative")
    choice = input("Enter choice (1-3): ").strip()
    modes = {'1': 'aggressive', '2': 'neutral', '3': 'conservative'}
    return modes.get(choice, 'neutral')

# =====================
# MAIN EXECUTION
# =====================
def main():
    global engine
    selected_mode = select_trading_mode()
    engine = BacktestEngine(mode=selected_mode)
    ib = IB()
    
    try:
        ib.connect('127.0.0.1', 7497, clientId=1)
        logger.info("Connected to IBKR")
        initial_balance = engine.balance
        
        daily_data = get_historical_data(ib, symbol, backtest=True)
        if daily_data is None or daily_data.empty:
            logger.error("Failed to retrieve historical data")
            raise ValueError("Failed to retrieve historical data")
        
        daily_data = run_backtest(daily_data)
        logger.info(f"Backtest completed with {len(engine.trade_history)} trades")
        plot_candlestick(daily_data, backtest=True)
        
        if engine.trade_history:
            trade_df = pd.DataFrame(engine.trade_history)
            total_pnl = trade_df['pnl'].sum()
            logger.info(f"Total PnL: ${total_pnl:.2f}")
            logger.info(f"Final Balance: ${engine.balance:.2f}")
            trade_df.to_csv('trade_history.csv')
            
            start_date = pd.to_datetime(trade_df['timestamp'].min()).tz_convert('America/New_York')
            end_date = pd.to_datetime(trade_df['timestamp'].max()).tz_convert('America/New_York')
            plot_pnl_calendar(engine, start_date, end_date, initial_balance, symbol)
    except Exception as e:
        logger.error(f"Main execution error: {str(e)}", exc_info=True)
    finally:
        if ib.isConnected():
            ib.disconnect()
            logger.info("Disconnected from IBKR")

if __name__ == '__main__':
    main()
